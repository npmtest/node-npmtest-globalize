{"/home/travis/build/npmtest/node-npmtest-globalize/test.js":"/* istanbul instrument in package npmtest_globalize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-globalize/lib.npmtest_globalize.js":"/* istanbul instrument in package npmtest_globalize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_globalize = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_globalize = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-globalize/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-globalize && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_globalize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_globalize\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_globalize.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_globalize.rollup.js'] =\n            local.assetsDict['/assets.npmtest_globalize.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_globalize.__dirname + '/lib.npmtest_globalize.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-globalize/node_modules/globalize/dist/node-main.js":"/*!\n * Globalize v1.2.3\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2017-03-17T01:41Z\n */\n\n// Core\nmodule.exports = require( \"./globalize\" );\n\n// Extent core with the following modules\nrequire( \"./globalize/message\" );\nrequire( \"./globalize/number\" );\nrequire( \"./globalize/plural\" );\n\n// Load after globalize/number\nrequire( \"./globalize/currency\" );\nrequire( \"./globalize/date\" );\n\n// Load after globalize/number and globalize/plural\nrequire( \"./globalize/relative-time\" );\nrequire( \"./globalize/unit\" );\n","/home/travis/build/npmtest/node-npmtest-globalize/node_modules/globalize/dist/globalize.js":"/**\n * Globalize v1.2.3\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2017-03-17T01:41Z\n */\n/*!\n * Globalize v1.2.3 2017-03-17T01:41Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"cldr/event\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ) );\n\t} else {\n\n\t\t// Global\n\t\troot.Globalize = factory( root.Cldr );\n\t}\n}( this, function( Cldr ) {\n\n\n/**\n * A toString method that outputs meaningful values for objects or arrays and\n * still performs as fast as a plain string in case variable is string, or as\n * fast as `\"\" + number` in case variable is a number.\n * Ref: http://jsperf.com/my-stringify\n */\nvar toString = function( variable ) {\n\treturn typeof variable === \"string\" ? variable : ( typeof variable === \"number\" ? \"\" +\n\t\tvariable : JSON.stringify( variable ) );\n};\n\n\n\n\n/**\n * formatMessage( message, data )\n *\n * @message [String] A message with optional {vars} to be replaced.\n *\n * @data [Array or JSON] Object with replacing-variables content.\n *\n * Return the formatted message. For example:\n *\n * - formatMessage( \"{0} second\", [ 1 ] ); // 1 second\n *\n * - formatMessage( \"{0}/{1}\", [\"m\", \"s\"] ); // m/s\n *\n * - formatMessage( \"{name} <{email}>\", {\n *     name: \"Foo\",\n *     email: \"bar@baz.qux\"\n *   }); // Foo <bar@baz.qux>\n */\nvar formatMessage = function( message, data ) {\n\n\t// Replace {attribute}'s\n\tmessage = message.replace( /{[0-9a-zA-Z-_. ]+}/g, function( name ) {\n\t\tname = name.replace( /^{([^}]*)}$/, \"$1\" );\n\t\treturn toString( data[ name ] );\n\t});\n\n\treturn message;\n};\n\n\n\n\nvar objectExtend = function() {\n\tvar destination = arguments[ 0 ],\n\t\tsources = [].slice.call( arguments, 1 );\n\n\tsources.forEach(function( source ) {\n\t\tvar prop;\n\t\tfor ( prop in source ) {\n\t\t\tdestination[ prop ] = source[ prop ];\n\t\t}\n\t});\n\n\treturn destination;\n};\n\n\n\n\nvar createError = function( code, message, attributes ) {\n\tvar error;\n\n\tmessage = code + ( message ? \": \" + formatMessage( message, attributes ) : \"\" );\n\terror = new Error( message );\n\terror.code = code;\n\n\tobjectExtend( error, attributes );\n\n\treturn error;\n};\n\n\n\n\n// Based on http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\nvar stringHash = function( str ) {\n\treturn [].reduce.call( str, function( hash, i ) {\n\t\tvar chr = i.charCodeAt( 0 );\n\t\thash = ( ( hash << 5 ) - hash ) + chr;\n\t\treturn hash | 0;\n\t}, 0 );\n};\n\n\n\n\nvar runtimeKey = function( fnName, locale, args, argsStr ) {\n\tvar hash;\n\targsStr = argsStr || JSON.stringify( args );\n\thash = stringHash( fnName + locale + argsStr );\n\treturn hash > 0 ? \"a\" + hash : \"b\" + Math.abs( hash );\n};\n\n\n\n\nvar functionName = function( fn ) {\n\tif ( fn.name !== undefined ) {\n\t\treturn fn.name;\n\t}\n\n\t// fn.name is not supported by IE.\n\tvar matches = /^function\\s+([\\w\\$]+)\\s*\\(/.exec( fn.toString() );\n\n\tif ( matches && matches.length > 0 ) {\n\t\treturn matches[ 1 ];\n\t}\n};\n\n\n\n\nvar runtimeBind = function( args, cldr, fn, runtimeArgs ) {\n\n\tvar argsStr = JSON.stringify( args ),\n\t\tfnName = functionName( fn ),\n\t\tlocale = cldr.locale;\n\n\t// If name of the function is not available, this is most likely due uglification,\n\t// which most likely means we are in production, and runtimeBind here is not necessary.\n\tif ( !fnName ) {\n\t\treturn fn;\n\t}\n\n\tfn.runtimeKey = runtimeKey( fnName, locale, null, argsStr );\n\n\tfn.generatorString = function() {\n\t\treturn \"Globalize(\\\"\" + locale + \"\\\").\" + fnName + \"(\" + argsStr.slice( 1, -1 ) + \")\";\n\t};\n\n\tfn.runtimeArgs = runtimeArgs;\n\n\treturn fn;\n};\n\n\n\n\nvar validate = function( code, message, check, attributes ) {\n\tif ( !check ) {\n\t\tthrow createError( code, message, attributes );\n\t}\n};\n\n\n\n\nvar alwaysArray = function( stringOrArray ) {\n\treturn Array.isArray( stringOrArray ) ? stringOrArray : stringOrArray ? [ stringOrArray ] : [];\n};\n\n\n\n\nvar validateCldr = function( path, value, options ) {\n\tvar skipBoolean;\n\toptions = options || {};\n\n\tskipBoolean = alwaysArray( options.skip ).some(function( pathRe ) {\n\t\treturn pathRe.test( path );\n\t});\n\n\tvalidate( \"E_MISSING_CLDR\", \"Missing required CLDR content `{path}`.\", value || skipBoolean, {\n\t\tpath: path\n\t});\n};\n\n\n\n\nvar validateDefaultLocale = function( value ) {\n\tvalidate( \"E_DEFAULT_LOCALE_NOT_DEFINED\", \"Default locale has not been defined.\",\n\t\tvalue !== undefined, {} );\n};\n\n\n\n\nvar validateParameterPresence = function( value, name ) {\n\tvalidate( \"E_MISSING_PARAMETER\", \"Missing required parameter `{name}`.\",\n\t\tvalue !== undefined, { name: name });\n};\n\n\n\n\n/**\n * range( value, name, minimum, maximum )\n *\n * @value [Number].\n *\n * @name [String] name of variable.\n *\n * @minimum [Number]. The lowest valid value, inclusive.\n *\n * @maximum [Number]. The greatest valid value, inclusive.\n */\nvar validateParameterRange = function( value, name, minimum, maximum ) {\n\tvalidate(\n\t\t\"E_PAR_OUT_OF_RANGE\",\n\t\t\"Parameter `{name}` has value `{value}` out of range [{minimum}, {maximum}].\",\n\t\tvalue === undefined || value >= minimum && value <= maximum,\n\t\t{\n\t\t\tmaximum: maximum,\n\t\t\tminimum: minimum,\n\t\t\tname: name,\n\t\t\tvalue: value\n\t\t}\n\t);\n};\n\n\n\n\nvar validateParameterType = function( value, name, check, expected ) {\n\tvalidate(\n\t\t\"E_INVALID_PAR_TYPE\",\n\t\t\"Invalid `{name}` parameter ({value}). {expected} expected.\",\n\t\tcheck,\n\t\t{\n\t\t\texpected: expected,\n\t\t\tname: name,\n\t\t\tvalue: value\n\t\t}\n\t);\n};\n\n\n\n\nvar validateParameterTypeLocale = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"string\" || value instanceof Cldr,\n\t\t\"String or Cldr instance\"\n\t);\n};\n\n\n\n\n/**\n * Function inspired by jQuery Core, but reduced to our use case.\n */\nvar isPlainObject = function( obj ) {\n\treturn obj !== null && \"\" + obj === \"[object Object]\";\n};\n\n\n\n\nvar validateParameterTypePlainObject = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || isPlainObject( value ),\n\t\t\"Plain Object\"\n\t);\n};\n\n\n\n\nvar alwaysCldr = function( localeOrCldr ) {\n\treturn localeOrCldr instanceof Cldr ? localeOrCldr : new Cldr( localeOrCldr );\n};\n\n\n\n\n// ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions\nvar regexpEscape = function( string ) {\n\treturn string.replace( /([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\" );\n};\n\n\n\n\nvar stringPad = function( str, count, right ) {\n\tvar length;\n\tif ( typeof str !== \"string\" ) {\n\t\tstr = String( str );\n\t}\n\tfor ( length = str.length; length < count; length += 1 ) {\n\t\tstr = ( right ? ( str + \"0\" ) : ( \"0\" + str ) );\n\t}\n\treturn str;\n};\n\n\n\n\nfunction validateLikelySubtags( cldr ) {\n\tcldr.once( \"get\", validateCldr );\n\tcldr.get( \"supplemental/likelySubtags\" );\n}\n\n/**\n * [new] Globalize( locale|cldr )\n *\n * @locale [String]\n *\n * @cldr [Cldr instance]\n *\n * Create a Globalize instance.\n */\nfunction Globalize( locale ) {\n\tif ( !( this instanceof Globalize ) ) {\n\t\treturn new Globalize( locale );\n\t}\n\n\tvalidateParameterPresence( locale, \"locale\" );\n\tvalidateParameterTypeLocale( locale, \"locale\" );\n\n\tthis.cldr = alwaysCldr( locale );\n\n\tvalidateLikelySubtags( this.cldr );\n}\n\n/**\n * Globalize.load( json, ... )\n *\n * @json [JSON]\n *\n * Load resolved or unresolved cldr data.\n * Somewhat equivalent to previous Globalize.addCultureInfo(...).\n */\nGlobalize.load = function() {\n\n\t// validations are delegated to Cldr.load().\n\tCldr.load.apply( Cldr, arguments );\n};\n\n/**\n * Globalize.locale( [locale|cldr] )\n *\n * @locale [String]\n *\n * @cldr [Cldr instance]\n *\n * Set default Cldr instance if locale or cldr argument is passed.\n *\n * Return the default Cldr instance.\n */\nGlobalize.locale = function( locale ) {\n\tvalidateParameterTypeLocale( locale, \"locale\" );\n\n\tif ( arguments.length ) {\n\t\tthis.cldr = alwaysCldr( locale );\n\t\tvalidateLikelySubtags( this.cldr );\n\t}\n\treturn this.cldr;\n};\n\n/**\n * Optimization to avoid duplicating some internal functions across modules.\n */\nGlobalize._alwaysArray = alwaysArray;\nGlobalize._createError = createError;\nGlobalize._formatMessage = formatMessage;\nGlobalize._isPlainObject = isPlainObject;\nGlobalize._objectExtend = objectExtend;\nGlobalize._regexpEscape = regexpEscape;\nGlobalize._runtimeBind = runtimeBind;\nGlobalize._stringPad = stringPad;\nGlobalize._validate = validate;\nGlobalize._validateCldr = validateCldr;\nGlobalize._validateDefaultLocale = validateDefaultLocale;\nGlobalize._validateParameterPresence = validateParameterPresence;\nGlobalize._validateParameterRange = validateParameterRange;\nGlobalize._validateParameterTypePlainObject = validateParameterTypePlainObject;\nGlobalize._validateParameterType = validateParameterType;\n\nreturn Globalize;\n\n\n\n\n}));\n","/home/travis/build/npmtest/node-npmtest-globalize/node_modules/globalize/dist/globalize/message.js":"/**\n * Globalize v1.2.3\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2017-03-17T01:41Z\n */\n/*!\n * Globalize v1.2.3 2017-03-17T01:41Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"cldr/event\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Extend global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar alwaysArray = Globalize._alwaysArray,\n\tcreateError = Globalize._createError,\n\tisPlainObject = Globalize._isPlainObject,\n\truntimeBind = Globalize._runtimeBind,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidate = Globalize._validate,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\nvar MessageFormat;\n/* jshint ignore:start */\nMessageFormat = (function() {\nMessageFormat._parse = (function() {\n\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = [],\n        peg$c1 = function(st) {\n              return { type: 'messageFormatPattern', statements: st };\n            },\n        peg$c2 = peg$FAILED,\n        peg$c3 = \"{\",\n        peg$c4 = { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n        peg$c5 = null,\n        peg$c6 = \",\",\n        peg$c7 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c8 = \"}\",\n        peg$c9 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n        peg$c10 = function(argIdx, efmt) {\n              var res = {\n                type: \"messageFormatElement\",\n                argumentIndex: argIdx\n              };\n              if (efmt && efmt.length) {\n                res.elementFormat = efmt[1];\n              } else {\n                res.output = true;\n              }\n              return res;\n            },\n        peg$c11 = \"plural\",\n        peg$c12 = { type: \"literal\", value: \"plural\", description: \"\\\"plural\\\"\" },\n        peg$c13 = function(t, s) {\n              return { type: \"elementFormat\", key: t, val: s };\n            },\n        peg$c14 = \"selectordinal\",\n        peg$c15 = { type: \"literal\", value: \"selectordinal\", description: \"\\\"selectordinal\\\"\" },\n        peg$c16 = \"select\",\n        peg$c17 = { type: \"literal\", value: \"select\", description: \"\\\"select\\\"\" },\n        peg$c18 = function(t, p) {\n              return { type: \"elementFormat\", key: t, val: p };\n            },\n        peg$c19 = function(op, pf) {\n              return { type: \"pluralFormatPattern\", pluralForms: pf, offset: op || 0 };\n            },\n        peg$c20 = \"offset\",\n        peg$c21 = { type: \"literal\", value: \"offset\", description: \"\\\"offset\\\"\" },\n        peg$c22 = \":\",\n        peg$c23 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c24 = function(d) { return d; },\n        peg$c25 = function(k, mfp) {\n              return { key: k, val: mfp };\n            },\n        peg$c26 = function(i) { return i; },\n        peg$c27 = \"=\",\n        peg$c28 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c29 = function(pf) { return { type: \"selectFormatPattern\", pluralForms: pf }; },\n        peg$c30 = function(p) { return p; },\n        peg$c31 = \"#\",\n        peg$c32 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n        peg$c33 = function() { return {type: 'octothorpe'}; },\n        peg$c34 = function(s) { return { type: \"string\", val: s.join('') }; },\n        peg$c35 = { type: \"other\", description: \"identifier\" },\n        peg$c36 = /^[0-9a-zA-Z$_]/,\n        peg$c37 = { type: \"class\", value: \"[0-9a-zA-Z$_]\", description: \"[0-9a-zA-Z$_]\" },\n        peg$c38 = /^[^ \\t\\n\\r,.+={}]/,\n        peg$c39 = { type: \"class\", value: \"[^ \\\\t\\\\n\\\\r,.+={}]\", description: \"[^ \\\\t\\\\n\\\\r,.+={}]\" },\n        peg$c40 = function(s) { return s; },\n        peg$c41 = function(chars) { return chars.join(''); },\n        peg$c42 = /^[^{}#\\\\\\0-\\x1F \\t\\n\\r]/,\n        peg$c43 = { type: \"class\", value: \"[^{}#\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]\", description: \"[^{}#\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]\" },\n        peg$c44 = function(x) { return x; },\n        peg$c45 = \"\\\\\\\\\",\n        peg$c46 = { type: \"literal\", value: \"\\\\\\\\\", description: \"\\\"\\\\\\\\\\\\\\\\\\\"\" },\n        peg$c47 = function() { return \"\\\\\"; },\n        peg$c48 = \"\\\\#\",\n        peg$c49 = { type: \"literal\", value: \"\\\\#\", description: \"\\\"\\\\\\\\#\\\"\" },\n        peg$c50 = function() { return \"#\"; },\n        peg$c51 = \"\\\\{\",\n        peg$c52 = { type: \"literal\", value: \"\\\\{\", description: \"\\\"\\\\\\\\{\\\"\" },\n        peg$c53 = function() { return \"\\u007B\"; },\n        peg$c54 = \"\\\\}\",\n        peg$c55 = { type: \"literal\", value: \"\\\\}\", description: \"\\\"\\\\\\\\}\\\"\" },\n        peg$c56 = function() { return \"\\u007D\"; },\n        peg$c57 = \"\\\\u\",\n        peg$c58 = { type: \"literal\", value: \"\\\\u\", description: \"\\\"\\\\\\\\u\\\"\" },\n        peg$c59 = function(h1, h2, h3, h4) {\n              return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));\n            },\n        peg$c60 = /^[0-9]/,\n        peg$c61 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c62 = function(ds) {\n            //the number might start with 0 but must not be interpreted as an octal number\n            //Hence, the base is passed to parseInt explicitely\n            return parseInt((ds.join('')), 10);\n          },\n        peg$c63 = /^[0-9a-fA-F]/,\n        peg$c64 = { type: \"class\", value: \"[0-9a-fA-F]\", description: \"[0-9a-fA-F]\" },\n        peg$c65 = { type: \"other\", description: \"whitespace\" },\n        peg$c66 = function(w) { return w.join(''); },\n        peg$c67 = /^[ \\t\\n\\r]/,\n        peg$c68 = { type: \"class\", value: \"[ \\\\t\\\\n\\\\r]\", description: \"[ \\\\t\\\\n\\\\r]\" },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsestart() {\n      var s0;\n\n      s0 = peg$parsemessageFormatPattern();\n\n      return s0;\n    }\n\n    function peg$parsemessageFormatPattern() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsemessageFormatElement();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsestring();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseoctothorpe();\n        }\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsemessageFormatElement();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsestring();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseoctothorpe();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c1(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsemessageFormatElement() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c3;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseid();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c6;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c7); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseelementFormat();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c2;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c2;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = peg$c5;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 125) {\n                  s6 = peg$c8;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c10(s3, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parseelementFormat() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c11) {\n          s2 = peg$c11;\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c12); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s4 = peg$c6;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c7); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsepluralFormatPattern();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c13(s2, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 13) === peg$c14) {\n            s2 = peg$c14;\n            peg$currPos += 13;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c15); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s4 = peg$c6;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c7); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parse_();\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parsepluralFormatPattern();\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parse_();\n                    if (s7 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c13(s2, s6);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c16) {\n              s2 = peg$c16;\n              peg$currPos += 6;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s4 = peg$c6;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c7); }\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parseselectFormatPattern();\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n                      if (s7 !== peg$FAILED) {\n                        peg$reportedPos = s0;\n                        s1 = peg$c13(s2, s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseid();\n              if (s2 !== peg$FAILED) {\n                s3 = [];\n                s4 = peg$parseargStylePattern();\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  s4 = peg$parseargStylePattern();\n                }\n                if (s3 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c18(s2, s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsepluralFormatPattern() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseoffsetPattern();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c5;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsepluralForm();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsepluralForm();\n          }\n        } else {\n          s2 = peg$c2;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parseoffsetPattern() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c20) {\n          s2 = peg$c20;\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s4 = peg$c22;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsedigits();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c24(s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepluralForm() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsepluralKey();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 123) {\n              s4 = peg$c3;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c4); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsemessageFormatPattern();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                      s8 = peg$c8;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c25(s2, s6);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepluralKey() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseid();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s1 = peg$c27;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsedigits();\n          if (s2 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c24(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseselectFormatPattern() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseselectForm();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseselectForm();\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c29(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseselectForm() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseid();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 123) {\n              s4 = peg$c3;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c4); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsemessageFormatPattern();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                      s8 = peg$c8;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c25(s2, s6);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parseargStylePattern() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c7); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseid();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c30(s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parseoctothorpe() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c33();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsechars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsewhitespace();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsechars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsewhitespace();\n          }\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseid() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        if (peg$c36.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c2;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s3 = input.substring(s2, peg$currPos);\n        }\n        s2 = s3;\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c40(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c35); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsechars() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsechar();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsechar();\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c41(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsechar() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (peg$c42.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c43); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c44(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c45) {\n          s1 = peg$c45;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c47();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c48) {\n            s1 = peg$c48;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c49); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c50();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 2) === peg$c51) {\n              s1 = peg$c51;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c53();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.substr(peg$currPos, 2) === peg$c54) {\n                s1 = peg$c54;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c55); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c56();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.substr(peg$currPos, 2) === peg$c57) {\n                  s1 = peg$c57;\n                  peg$currPos += 2;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parsehexDigit();\n                  if (s2 !== peg$FAILED) {\n                    s3 = peg$parsehexDigit();\n                    if (s3 !== peg$FAILED) {\n                      s4 = peg$parsehexDigit();\n                      if (s4 !== peg$FAILED) {\n                        s5 = peg$parsehexDigit();\n                        if (s5 !== peg$FAILED) {\n                          peg$reportedPos = s0;\n                          s1 = peg$c59(s2, s3, s4, s5);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsedigits() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c60.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c62(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsehexDigit() {\n      var s0;\n\n      if (peg$c63.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c64); }\n      }\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsewhitespace();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewhitespace();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c66(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsewhitespace() {\n      var s0;\n\n      if (peg$c67.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c68); }\n      }\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n}()).parse;\n\n\n/** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript\n *  @author Alex Sexton - @SlexAxton\n *  @version 0.3.0-1\n *  @copyright 2012-2015 Alex Sexton, Eemeli Aro, and Contributors\n *  @license To use or fork, MIT. To contribute back, Dojo CLA  */\n\n\n/** Utility function for quoting an Object's key value iff required\n *  @private  */\nfunction propname(key, obj) {\n  if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key)) {\n    return obj ? obj + '.' + key : key;\n  } else {\n    var jkey = JSON.stringify(key);\n    return obj ? obj + '[' + jkey + ']' : jkey;\n  }\n};\n\n\n/** Create a new message formatter\n *\n *  @class\n *  @global\n *  @param {string|string[]} [locale=\"en\"] - The locale to use, with fallbacks\n *  @param {function} [pluralFunc] - Optional custom pluralization function\n *  @param {function[]} [formatters] - Optional custom formatting functions  */\nfunction MessageFormat(locale, pluralFunc, formatters) {\n  this.lc = [locale];  \n  this.runtime.pluralFuncs = {};\n  this.runtime.pluralFuncs[this.lc[0]] = pluralFunc;\n  this.runtime.fmt = {};\n  if (formatters) for (var f in formatters) {\n    this.runtime.fmt[f] = formatters[f];\n  }\n}\n\n\n\n\n/** Parse an input string to its AST\n *\n *  Precompiled from `lib/messageformat-parser.pegjs` by\n *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object\n *  to enable testing.\n *\n *  @private  */\n\n\n\n/** Pluralization functions from\n *  {@link http://github.com/eemeli/make-plural.js make-plural}\n *\n *  @memberof MessageFormat\n *  @type Object.<string,function>  */\nMessageFormat.plurals = {};\n\n\n/** Default number formatting functions in the style of ICU's\n *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}\n *  implemented using the\n *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}\n *  object defined by ECMA-402.\n *\n *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so\n *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.\n *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these\n *  functions to be available for inclusion in the output.\n *\n *  @see MessageFormat#setIntlSupport\n *\n *  @namespace\n *  @memberof MessageFormat\n *  @property {function} number - Represent a number as an integer, percent or currency value\n *  @property {function} date - Represent a date as a full/long/default/short string\n *  @property {function} time - Represent a time as a full/long/default/short string\n *\n *  @example\n *  > var MessageFormat = require('messageformat');\n *  > var mf = (new MessageFormat('en')).setIntlSupport(true);\n *  > mf.currency = 'EUR';\n *  > var mfunc = mf.compile(\"The total is {V,number,currency}.\");\n *  > mfunc({V:5.5})\n *  \"The total is €5.50.\"\n *\n *  @example\n *  > var MessageFormat = require('messageformat');\n *  > var mf = new MessageFormat('en', null, {number: MessageFormat.number});\n *  > mf.currency = 'EUR';\n *  > var mfunc = mf.compile(\"The total is {V,number,currency}.\");\n *  > mfunc({V:5.5})\n *  \"The total is €5.50.\"  */\nMessageFormat.formatters = {};\n\n/** Enable or disable support for the default formatters, which require the\n *  `Intl` object. Note that this can't be autodetected, as the environment\n *  in which the formatted text is compiled into Javascript functions is not\n *  necessarily the same environment in which they will get executed.\n *\n *  @see MessageFormat.formatters\n *\n *  @memberof MessageFormat\n *  @param {boolean} [enable=true]\n *  @returns {Object} The MessageFormat instance, to allow for chaining\n *  @example\n *  > var Intl = require('intl');\n *  > var MessageFormat = require('messageformat');\n *  > var mf = (new MessageFormat('en')).setIntlSupport(true);\n *  > mf.currency = 'EUR';\n *  > mf.compile(\"The total is {V,number,currency}.\")({V:5.5});\n *  \"The total is €5.50.\"  */\n\n\n\n/** A set of utility functions that are called by the compiled Javascript\n *  functions, these are included locally in the output of {@link\n *  MessageFormat#compile compile()}.\n *\n *  @namespace\n *  @memberof MessageFormat  */\nMessageFormat.prototype.runtime = {\n\n  /** Utility function for `#` in plural rules\n   *\n   *  @param {number} value - The value to operate on\n   *  @param {number} [offset=0] - An optional offset, set by the surrounding context  */\n  number: function(value, offset) {\n    if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n    return value - (offset || 0);\n  },\n\n  /** Utility function for `{N, plural|selectordinal, ...}`\n   *\n   *  @param {number} value - The key to use to find a pluralization rule\n   *  @param {number} offset - An offset to apply to `value`\n   *  @param {function} lcfunc - A locale function from `pluralFuncs`\n   *  @param {Object.<string,string>} data - The object from which results are looked up\n   *  @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules\n   *  @returns {string} The result of the pluralization  */\n  plural: function(value, offset, lcfunc, data, isOrdinal) {\n    if ({}.hasOwnProperty.call(data, value)) return data[value]();\n    if (offset) value -= offset;\n    var key = lcfunc(value, isOrdinal);\n    if (key in data) return data[key]();\n    return data.other();\n  },\n\n  /** Utility function for `{N, select, ...}`\n   *\n   *  @param {number} value - The key to use to find a selection\n   *  @param {Object.<string,string>} data - The object from which results are looked up\n   *  @returns {string} The result of the select statement  */\n  select: function(value, data) {\n    if ({}.hasOwnProperty.call(data, value)) return data[value]();\n    return data.other()\n  },\n\n  /** Pluralization functions included in compiled output\n   *  @instance\n   *  @type Object.<string,function>  */\n  pluralFuncs: {},\n\n  /** Custom formatting functions called by `{var, fn[, args]*}` syntax\n   *\n   *  For examples, see {@link MessageFormat.formatters}\n   *\n   *  @instance\n   *  @see MessageFormat.formatters\n   *  @type Object.<string,function>  */\n  fmt: {},\n\n  /** Custom stringifier to clean up browser inconsistencies\n   *  @instance  */\n  toString: function () {\n    var _stringify = function(o, level) {\n      if (typeof o != 'object') {\n        var funcStr = o.toString().replace(/^(function )\\w*/, '$1');\n        var indent = /([ \\t]*)\\S.*$/.exec(funcStr);\n        return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;\n      }\n      var s = [];\n      for (var i in o) if (i != 'toString') {\n        if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\\n');\n        else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));\n      }\n      if (level == 0) return s.join('');\n      if (s.length == 0) return '{}';\n      var indent = '  '; while (--level) indent += '  ';\n      return '{\\n' + s.join(',\\n').replace(/^/gm, indent) + '\\n}';\n    };\n    return _stringify(this, 0);\n  }\n};\n\n\n/** Recursively map an AST to its resulting string\n *\n *  @memberof MessageFormat\n *\n *  @param ast - the Ast node for which the JS code should be generated\n *\n *  @private  */\nMessageFormat.prototype._precompile = function(ast, data) {\n  data = data || { keys: {}, offset: {} };\n  var r = [], i, tmp, args = [];\n\n  switch ( ast.type ) {\n    case 'messageFormatPattern':\n      for ( i = 0; i < ast.statements.length; ++i ) {\n        r.push(this._precompile( ast.statements[i], data ));\n      }\n      tmp = r.join(' + ') || '\"\"';\n      return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';\n\n    case 'messageFormatElement':\n      data.pf_count = data.pf_count || 0;\n      if ( ast.output ) {\n        return propname(ast.argumentIndex, 'd');\n      }\n      else {\n        data.keys[data.pf_count] = ast.argumentIndex;\n        return this._precompile( ast.elementFormat, data );\n      }\n      return '';\n\n    case 'elementFormat':\n      args = [ propname(data.keys[data.pf_count], 'd') ];\n      switch (ast.key) {\n        case 'select':\n          args.push(this._precompile(ast.val, data));\n          return 'select(' + args.join(', ') + ')';\n        case 'selectordinal':\n          args = args.concat([ 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1 ]);\n          return 'plural(' + args.join(', ') + ')';\n        case 'plural':\n          data.offset[data.pf_count || 0] = ast.val.offset || 0;\n          args = args.concat([ data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data) ]);\n          return 'plural(' + args.join(', ') + ')';\n        default:\n          if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && (ast.key in MessageFormat.formatters)) {\n            tmp = MessageFormat.formatters[ast.key];\n            this.runtime.fmt[ast.key] = (typeof tmp(this) == 'function') ? tmp(this) : tmp;\n          }\n          args.push(JSON.stringify(this.lc));\n          if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));\n          return 'fmt.' + ast.key + '(' + args.join(', ') + ')';\n      }\n\n    case 'pluralFormatPattern':\n    case 'selectFormatPattern':\n      data.pf_count = data.pf_count || 0;\n      if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;\n      var needOther = true;\n      for (i = 0; i < ast.pluralForms.length; ++i) {\n        var key = ast.pluralForms[i].key;\n        if (key === 'other') needOther = false;\n        var data_copy = JSON.parse(JSON.stringify(data));\n        data_copy.pf_count++;\n        r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');\n      }\n      if (needOther) throw new Error(\"No 'other' form found in \" + ast.type + \" \" + data.pf_count);\n      return '{ ' + r.join(', ') + ' }';\n\n    case 'string':\n      return JSON.stringify(ast.val || \"\");\n\n    case 'octothorpe':\n      if (!data.pf_count) return '\"#\"';\n      args = [ propname(data.keys[data.pf_count-1], 'd') ];\n      if (data.offset[data.pf_count-1]) args.push(data.offset[data.pf_count-1]);\n      return 'number(' + args.join(', ') + ')';\n\n    default:\n      throw new Error( 'Bad AST type: ' + ast.type );\n  }\n};\n\n/** Compile messages into an executable function with clean string\n *  representation.\n *\n *  If `messages` is a single string including ICU MessageFormat declarations,\n *  `opt` is ignored and the returned function takes a single Object parameter\n *  `d` representing each of the input's defined variables. The returned\n *  function will be defined in a local scope that includes all the required\n *  runtime variables.\n *\n *  If `messages` is a map of keys to strings, or a map of namespace keys to\n *  such key/string maps, the returned function will fill the specified global\n *  with javascript functions matching the structure of the input. In such use,\n *  the output of `compile()` is expected to be serialized using `.toString()`,\n *  and will include definitions of the runtime functions. If `opt.global` is\n *  null, calling the output function will return the object itself.\n *\n *  Together, the input parameters should match the following patterns:\n *  ```js\n *  messages = \"string\" || { key0: \"string0\", key1: \"string1\", ... } || {\n *    ns0: { key0: \"string0\", key1: \"string1\", ...  },\n *    ns1: { key0: \"string0\", key1: \"string1\", ...  },\n *    ...\n *  }\n *\n *  opt = null || {\n *    locale: null || {\n *      ns0: \"lc0\" || [ \"lc0\", ... ],\n *      ns1: \"lc1\" || [ \"lc1\", ... ],\n *      ...\n *    },\n *    global: null || \"module.exports\" || \"exports\" || \"i18n\" || ...\n *  }\n *  ```\n *\n *  @memberof MessageFormat\n *  @param {string|Object}\n *      messages - The input message(s) to be compiled, in ICU MessageFormat\n *  @param {Object} [opt={}] - Options controlling output for non-simple intput\n *  @param {Object} [opt.locale] - The locales to use for the messages, with a\n *      structure matching that of `messages`\n *  @param {string} [opt.global=\"\"] - The global variable that the output\n *      function should use, or a null string for none. \"exports\" and\n *      \"module.exports\" are recognised as special cases.\n *  @returns {function} The first match found for the given locale(s)\n *\n *  @example\n * > var MessageFormat = require('messageformat'),\n * ...   mf = new MessageFormat('en'),\n * ...   mfunc0 = mf.compile('A {TYPE} example.');\n * > mfunc0({TYPE:'simple'})\n * 'A simple example.'\n * > mfunc0.toString()\n * 'function (d) { return \"A \" + d.TYPE + \" example.\"; }'\n *\n *  @example\n * > var msgSet = { a: 'A {TYPE} example.',\n * ...              b: 'This has {COUNT, plural, one{one member} other{# members}}.' },\n * ...   mfuncSet = mf.compile(msgSet);\n * > mfuncSet().a({TYPE:'more complex'})\n * 'A more complex example.'\n * > mfuncSet().b({COUNT:2})\n * 'This has 2 members.'\n *\n * > console.log(mfuncSet.toString())\n * function anonymous() {\n * var number = function (value, offset) {\n *   if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n *   return value - (offset || 0);\n * };\n * var plural = function (value, offset, lcfunc, data, isOrdinal) {\n *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n *   if (offset) value -= offset;\n *   var key = lcfunc(value, isOrdinal);\n *   if (key in data) return data[key]();\n *   return data.other();\n * };\n * var select = function (value, data) {\n *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n *   return data.other()\n * };\n * var pluralFuncs = {\n *   en: function (n, ord) {\n *     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,\n *         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n *     if (ord) return (n10 == 1 && n100 != 11) ? 'one'\n *         : (n10 == 2 && n100 != 12) ? 'two'\n *         : (n10 == 3 && n100 != 13) ? 'few'\n *         : 'other';\n *     return (n == 1 && v0) ? 'one' : 'other';\n *   }\n * };\n * var fmt = {};\n *\n * return {\n *   a: function(d) { return \"A \" + d.TYPE + \" example.\"; },\n *   b: function(d) { return \"This has \" + plural(d.COUNT, 0, pluralFuncs.en, { one: function() { return \"one member\";}, other: function() { return number(d.COUNT)+\" members\";} }) + \".\"; }\n * }\n * }\n *\n *  @example\n * > mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;\n * > var multiSet = { en: { a: 'A {TYPE} example.',\n * ...                      b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },\n * ...                fi: { a: '{TYPE} esimerkki.',\n * ...                      b: 'Tämä on {COUNT, selectordinal, other{#.}} esimerkki.' } },\n * ...   multiSetLocales = { en: 'en', fi: 'fi' },\n * ...   mfuncSet = mf.compile(multiSet, { locale: multiSetLocales, global: 'i18n' });\n * > mfuncSet(this);\n * > i18n.en.b({COUNT:3})\n * 'This is the 3rd example.'\n * > i18n.fi.b({COUNT:3})\n * 'Tämä on 3. esimerkki.'  */\nMessageFormat.prototype.compile = function ( messages, opt ) {\n  var r = {}, lc0 = this.lc,\n      compileMsg = function(self, msg) {\n        try {\n          var ast = MessageFormat._parse(msg);\n          return self._precompile(ast);\n        } catch (e) {\n          throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());\n        }\n      },\n      stringify = function(r, level) {\n        if (!level) level = 0;\n        if (typeof r != 'object') return r;\n        var o = [], indent = '';\n        for (var i = 0; i < level; ++i) indent += '  ';\n        for (var k in r) o.push('\\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));\n        return '{' + o.join(',') + '\\n' + indent + '}';\n      };\n\n  if (typeof messages == 'string') {\n    var f = new Function(\n        'number, plural, select, pluralFuncs, fmt',\n        'return ' + compileMsg(this, messages));\n    return f(this.runtime.number, this.runtime.plural, this.runtime.select,\n        this.runtime.pluralFuncs, this.runtime.fmt);\n  }\n\n  opt = opt || {};\n\n  for (var ns in messages) {\n    if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;\n    if (typeof messages[ns] == 'string') {\n      try { r[ns] = compileMsg(this, messages[ns]); }\n      catch (e) { e.message = e.message.replace(':', ' with `' + ns + '`:'); throw e; }\n    } else {\n      r[ns] = {};\n      for (var key in messages[ns]) {\n        try { r[ns][key] = compileMsg(this, messages[ns][key]); }\n        catch (e) { e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:'); throw e; }\n      }\n    }\n  }\n\n  this.lc = lc0;\n  var s = this.runtime.toString() + '\\n';\n  switch (opt.global || '') {\n    case 'exports':\n      var o = [];\n      for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));\n      return new Function(s + o.join(';\\n'));\n    case 'module.exports':\n      return new Function(s + 'module.exports = ' + stringify(r));\n    case '':\n      return new Function(s + 'return ' + stringify(r));\n    default:\n      return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));\n  }\n};\n\n\nreturn MessageFormat;\n}());\n/* jshint ignore:end */\n\n\nvar createErrorPluralModulePresence = function() {\n\treturn createError( \"E_MISSING_PLURAL_MODULE\", \"Plural module not loaded.\" );\n};\n\n\n\n\nvar validateMessageBundle = function( cldr ) {\n\tvalidate(\n\t\t\"E_MISSING_MESSAGE_BUNDLE\",\n\t\t\"Missing message bundle for locale `{locale}`.\",\n\t\tcldr.attributes.bundle && cldr.get( \"globalize-messages/{bundle}\" ) !== undefined,\n\t\t{\n\t\t\tlocale: cldr.locale\n\t\t}\n\t);\n};\n\n\n\n\nvar validateMessagePresence = function( path, value ) {\n\tpath = path.join( \"/\" );\n\tvalidate( \"E_MISSING_MESSAGE\", \"Missing required message content `{path}`.\",\n\t\tvalue !== undefined, { path: path } );\n};\n\n\n\n\nvar validateMessageType = function( path, value ) {\n\tpath = path.join( \"/\" );\n\tvalidate(\n\t\t\"E_INVALID_MESSAGE\",\n\t\t\"Invalid message content `{path}`. {expected} expected.\",\n\t\ttypeof value === \"string\",\n\t\t{\n\t\t\texpected: \"a string\",\n\t\t\tpath: path\n\t\t}\n\t);\n};\n\n\n\n\nvar validateParameterTypeMessageVariables = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || isPlainObject( value ) || Array.isArray( value ),\n\t\t\"Array or Plain Object\"\n\t);\n};\n\n\n\n\nvar messageFormatterFn = function( formatter ) {\n\treturn function messageFormatter( variables ) {\n\t\tif ( typeof variables === \"number\" || typeof variables === \"string\" ) {\n\t\t\tvariables = [].slice.call( arguments, 0 );\n\t\t}\n\t\tvalidateParameterTypeMessageVariables( variables, \"variables\" );\n\t\treturn formatter( variables );\n\t};\n};\n\n\n\n\nvar messageFormatterRuntimeBind = function( cldr, messageformatter ) {\n\tvar locale = cldr.locale,\n\t\torigToString = messageformatter.toString;\n\n\tmessageformatter.toString = function() {\n\t\tvar argNames, argValues, output,\n\t\t\targs = {};\n\n\t\t// Properly adjust SlexAxton/messageformat.js compiled variables with Globalize variables:\n\t\toutput = origToString.call( messageformatter );\n\n\t\tif ( /number\\(/.test( output ) ) {\n\t\t\targs.number = \"messageFormat.number\";\n\t\t}\n\n\t\tif ( /plural\\(/.test( output ) ) {\n\t\t\targs.plural = \"messageFormat.plural\";\n\t\t}\n\n\t\tif ( /select\\(/.test( output ) ) {\n\t\t\targs.select = \"messageFormat.select\";\n\t\t}\n\n\t\toutput.replace( /pluralFuncs(\\[([^\\]]+)\\]|\\.([a-zA-Z]+))/, function( match ) {\n\t\t\targs.pluralFuncs = \"{\" +\n\t\t\t\t\"\\\"\" + locale + \"\\\": Globalize(\\\"\" + locale + \"\\\").pluralGenerator()\" +\n\t\t\t\t\"}\";\n\t\t\treturn match;\n\t\t});\n\n\t\targNames = Object.keys( args ).join( \", \" );\n\t\targValues = Object.keys( args ).map(function( key ) {\n\t\t\treturn args[ key ];\n\t\t}).join( \", \" );\n\n\t\treturn \"(function( \" + argNames + \" ) {\\n\" +\n\t\t\t\"  return \" + output + \"\\n\" +\n\t\t\t\"})(\" + argValues + \")\";\n\t};\n\n\treturn messageformatter;\n};\n\n\n\n\nvar slice = [].slice;\n\n/**\n * .loadMessages( json )\n *\n * @json [JSON]\n *\n * Load translation data.\n */\nGlobalize.loadMessages = function( json ) {\n\tvar locale,\n\t\tcustomData = {\n\t\t\t\"globalize-messages\": json,\n\t\t\t\"main\": {}\n\t\t};\n\n\tvalidateParameterPresence( json, \"json\" );\n\tvalidateParameterTypePlainObject( json, \"json\" );\n\n\t// Set available bundles by populating customData main dataset.\n\tfor ( locale in json ) {\n\t\tif ( json.hasOwnProperty( locale ) ) {\n\t\t\tcustomData.main[ locale ] = {};\n\t\t}\n\t}\n\n\tCldr.load( customData );\n};\n\n/**\n * .messageFormatter( path )\n *\n * @path [String or Array]\n *\n * Format a message given its path.\n */\nGlobalize.messageFormatter =\nGlobalize.prototype.messageFormatter = function( path ) {\n\tvar cldr, formatter, message, pluralGenerator, returnFn,\n\t\targs = slice.call( arguments, 0 );\n\n\tvalidateParameterPresence( path, \"path\" );\n\tvalidateParameterType( path, \"path\", typeof path === \"string\" || Array.isArray( path ),\n\t\t\"a String nor an Array\" );\n\n\tpath = alwaysArray( path );\n\tcldr = this.cldr;\n\n\tvalidateDefaultLocale( cldr );\n\tvalidateMessageBundle( cldr );\n\n\tmessage = cldr.get( [ \"globalize-messages/{bundle}\" ].concat( path ) );\n\tvalidateMessagePresence( path, message );\n\n\t// If message is an Array, concatenate it.\n\tif ( Array.isArray( message ) ) {\n\t\tmessage = message.join( \" \" );\n\t}\n\tvalidateMessageType( path, message );\n\n\t// Is plural module present? Yes, use its generator. Nope, use an error generator.\n\tpluralGenerator = this.plural !== undefined ?\n\t\tthis.pluralGenerator() :\n\t\tcreateErrorPluralModulePresence;\n\n\tformatter = new MessageFormat( cldr.locale, pluralGenerator ).compile( message );\n\n\treturnFn = messageFormatterFn( formatter );\n\n\truntimeBind( args, cldr, returnFn,\n\t\t[ messageFormatterRuntimeBind( cldr, formatter ), pluralGenerator ] );\n\n\treturn returnFn;\n};\n\n/**\n * .formatMessage( path [, variables] )\n *\n * @path [String or Array]\n *\n * @variables [Number, String, Array or Object]\n *\n * Format a message given its path.\n */\nGlobalize.formatMessage =\nGlobalize.prototype.formatMessage = function( path /* , variables */ ) {\n\treturn this.messageFormatter( path ).apply( {}, slice.call( arguments, 1 ) );\n};\n\nreturn Globalize;\n\n\n\n\n}));\n","/home/travis/build/npmtest/node-npmtest-globalize/node_modules/globalize/dist/globalize/number.js":"/**\n * Globalize v1.2.3\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2017-03-17T01:41Z\n */\n/*!\n * Globalize v1.2.3 2017-03-17T01:41Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"cldr/event\",\n\t\t\t\"cldr/supplemental\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar createError = Globalize._createError,\n\tregexpEscape = Globalize._regexpEscape,\n\truntimeBind = Globalize._runtimeBind,\n\tstringPad = Globalize._stringPad,\n\tvalidateCldr = Globalize._validateCldr,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterRange = Globalize._validateParameterRange,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n\n\nvar createErrorUnsupportedFeature = function( feature ) {\n\treturn createError( \"E_UNSUPPORTED\", \"Unsupported {feature}.\", {\n\t\tfeature: feature\n\t});\n};\n\n\n\n\nvar validateParameterTypeNumber = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"number\",\n\t\t\"Number\"\n\t);\n};\n\n\n\n\nvar validateParameterTypeString = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"string\",\n\t\t\"a string\"\n\t);\n};\n\n\n\n\n/**\n * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )\n *\n * @number [Number].\n *\n * @primaryGroupingSize [Number]\n *\n * @secondaryGroupingSize [Number]\n *\n * Return the formatted number with group separator.\n */\nvar numberFormatGroupingSeparator = function( number, primaryGroupingSize, secondaryGroupingSize ) {\n\tvar index,\n\t\tcurrentGroupingSize = primaryGroupingSize,\n\t\tret = \"\",\n\t\tsep = \",\",\n\t\tswitchToSecondary = secondaryGroupingSize ? true : false;\n\n\tnumber = String( number ).split( \".\" );\n\tindex = number[ 0 ].length;\n\n\twhile ( index > currentGroupingSize ) {\n\t\tret = number[ 0 ].slice( index - currentGroupingSize, index ) +\n\t\t\t( ret.length ? sep : \"\" ) + ret;\n\t\tindex -= currentGroupingSize;\n\t\tif ( switchToSecondary ) {\n\t\t\tcurrentGroupingSize = secondaryGroupingSize;\n\t\t\tswitchToSecondary = false;\n\t\t}\n\t}\n\n\tnumber[ 0 ] = number[ 0 ].slice( 0, index ) + ( ret.length ? sep : \"\" ) + ret;\n\treturn number.join( \".\" );\n};\n\n\n\n\n/**\n * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, round, roundIncrement )\n *\n * @number [Number]\n *\n * @minimumIntegerDigits [Number]\n *\n * @minimumFractionDigits [Number]\n *\n * @maximumFractionDigits [Number]\n *\n * @round [Function]\n *\n * @roundIncrement [Function]\n *\n * Return the formatted integer and fraction digits.\n */\nvar numberFormatIntegerFractionDigits = function( number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round,\n\troundIncrement ) {\n\n\t// Fraction\n\tif ( maximumFractionDigits ) {\n\n\t\t// Rounding\n\t\tif ( roundIncrement ) {\n\t\t\tnumber = round( number, roundIncrement );\n\n\t\t// Maximum fraction digits\n\t\t} else {\n\t\t\tnumber = round( number, { exponent: -maximumFractionDigits } );\n\t\t}\n\n\t\t// Minimum fraction digits\n\t\tif ( minimumFractionDigits ) {\n\t\t\tnumber = String( number ).split( \".\" );\n\t\t\tnumber[ 1 ] = stringPad( number[ 1 ] || \"\", minimumFractionDigits, true );\n\t\t\tnumber = number.join( \".\" );\n\t\t}\n\t} else {\n\t\tnumber = round( number );\n\t}\n\n\tnumber = String( number );\n\n\t// Minimum integer digits\n\tif ( minimumIntegerDigits ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 0 ] = stringPad( number[ 0 ], minimumIntegerDigits );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\treturn number;\n};\n\n\n\n\n/**\n * toPrecision( number, precision, round )\n *\n * @number (Number)\n *\n * @precision (Number) significant figures precision (not decimal precision).\n *\n * @round (Function)\n *\n * Return number.toPrecision( precision ) using the given round function.\n */\nvar numberToPrecision = function( number, precision, round ) {\n\tvar roundOrder;\n\n\t// Get number at two extra significant figure precision.\n\tnumber = number.toPrecision( precision + 2 );\n\n\t// Then, round it to the required significant figure precision.\n\troundOrder = Math.ceil( Math.log( Math.abs( number ) ) / Math.log( 10 ) );\n\troundOrder -= precision;\n\n\treturn round( number, { exponent: roundOrder } );\n};\n\n\n\n\n/**\n * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )\n *\n * @number [Number]\n *\n * @minimumSignificantDigits [Number]\n *\n * @maximumSignificantDigits [Number]\n *\n * @round [Function]\n *\n * Return the formatted significant digits number.\n */\nvar numberFormatSignificantDigits = function( number, minimumSignificantDigits, maximumSignificantDigits, round ) {\n\tvar atMinimum, atMaximum;\n\n\t// Sanity check.\n\tif ( minimumSignificantDigits > maximumSignificantDigits ) {\n\t\tmaximumSignificantDigits = minimumSignificantDigits;\n\t}\n\n\tatMinimum = numberToPrecision( number, minimumSignificantDigits, round );\n\tatMaximum = numberToPrecision( number, maximumSignificantDigits, round );\n\n\t// Use atMaximum only if it has more significant digits than atMinimum.\n\tnumber = +atMinimum === +atMaximum ? atMinimum : atMaximum;\n\n\t// Expand integer numbers, eg. 123e5 to 12300.\n\tnumber = ( +number ).toString( 10 );\n\n\tif ( ( /e/ ).test( number ) ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"integers out of (1e21, 1e-7)\"\n\t\t});\n\t}\n\n\t// Add trailing zeros if necessary.\n\tif ( minimumSignificantDigits - number.replace( /^0+|\\./g, \"\" ).length > 0 ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 1 ] = stringPad( number[ 1 ] || \"\", minimumSignificantDigits - number[ 0 ].replace( /^0+/, \"\" ).length, true );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\treturn number;\n};\n\n\n\n\n/**\n * removeLiteralQuotes( string )\n *\n * Return:\n * - `` if input string is `''`.\n * - `o'clock` if input string is `'o''clock'`.\n * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted\n *   string.\n */\nvar removeLiteralQuotes = function( string ) {\n\tif ( string[ 0 ] + string[ string.length - 1 ] !== \"''\" ) {\n\t\treturn string;\n\t}\n\tif ( string === \"''\" ) {\n\t\treturn \"\";\n\t}\n\treturn string.replace( /''/g, \"'\" ).slice( 1, -1 );\n};\n\n\n\n\n/**\n * format( number, properties )\n *\n * @number [Number].\n *\n * @properties [Object] Output of number/format-properties.\n *\n * Return the formatted number.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberFormat = function( number, properties ) {\n\tvar infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,\n\tminimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix,\n\tprimaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix,\n\tsymbolMap;\n\n\tpadding = properties[ 1 ];\n\tminimumIntegerDigits = properties[ 2 ];\n\tminimumFractionDigits = properties[ 3 ];\n\tmaximumFractionDigits = properties[ 4 ];\n\tminimumSignificantDigits = properties[ 5 ];\n\tmaximumSignificantDigits = properties[ 6 ];\n\troundIncrement = properties[ 7 ];\n\tprimaryGroupingSize = properties[ 8 ];\n\tsecondaryGroupingSize = properties[ 9 ];\n\tround = properties[ 15 ];\n\tinfinitySymbol = properties[ 16 ];\n\tnanSymbol = properties[ 17 ];\n\tsymbolMap = properties[ 18 ];\n\tnuDigitsMap = properties[ 19 ];\n\n\t// NaN\n\tif ( isNaN( number ) ) {\n\t\treturn nanSymbol;\n\t}\n\n\tif ( number < 0 ) {\n\t\tpattern = properties[ 12 ];\n\t\tprefix = properties[ 13 ];\n\t\tsuffix = properties[ 14 ];\n\t} else {\n\t\tpattern = properties[ 11 ];\n\t\tprefix = properties[ 0 ];\n\t\tsuffix = properties[ 10 ];\n\t}\n\n\t// Infinity\n\tif ( !isFinite( number ) ) {\n\t\treturn prefix + infinitySymbol + suffix;\n\t}\n\n\tret = prefix;\n\n\t// Percent\n\tif ( pattern.indexOf( \"%\" ) !== -1 ) {\n\t\tnumber *= 100;\n\n\t// Per mille\n\t} else if ( pattern.indexOf( \"\\u2030\" ) !== -1 ) {\n\t\tnumber *= 1000;\n\t}\n\n\t// Significant digit format\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {\n\t\tnumber = numberFormatSignificantDigits( number, minimumSignificantDigits,\n\t\t\tmaximumSignificantDigits, round );\n\n\t// Integer and fractional format\n\t} else {\n\t\tnumber = numberFormatIntegerFractionDigits( number, minimumIntegerDigits,\n\t\t\tminimumFractionDigits, maximumFractionDigits, round, roundIncrement );\n\t}\n\n\t// Remove the possible number minus sign\n\tnumber = number.replace( /^-/, \"\" );\n\n\t// Grouping separators\n\tif ( primaryGroupingSize ) {\n\t\tnumber = numberFormatGroupingSeparator( number, primaryGroupingSize,\n\t\t\tsecondaryGroupingSize );\n\t}\n\n\tret += number;\n\n\t// Scientific notation\n\t// TODO implement here\n\n\t// Padding/'([^']|'')+'|''|[.,\\-+E%\\u2030]/g\n\t// TODO implement here\n\n\tret += suffix;\n\n\treturn ret.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {\n\n\t\t// Literals\n\t\tif ( literal ) {\n\t\t\treturn removeLiteralQuotes( literal );\n\t\t}\n\n\t\t// Symbols\n\t\tcharacter = character.replace( /[.,\\-+E%\\u2030]/, function( symbol ) {\n\t\t\treturn symbolMap[ symbol ];\n\t\t});\n\n\t\t// Numbering system\n\t\tif ( nuDigitsMap ) {\n\t\t\tcharacter = character.replace( /[0-9]/, function( digit ) {\n\t\t\t\treturn nuDigitsMap[ +digit ];\n\t\t\t});\n\t\t}\n\n\t\treturn character;\n\t});\n};\n\n\n\n\nvar numberFormatterFn = function( properties ) {\n\treturn function numberFormatter( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeNumber( value, \"value\" );\n\n\t\treturn numberFormat( value, properties );\n\t};\n};\n\n\n\n\n/**\n * NumberingSystem( cldr )\n *\n * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems\n * - http://cldr.unicode.org/index/bcp47-extension\n * - http://www.unicode.org/reports/tr35/#u_Extension\n */\nvar numberNumberingSystem = function( cldr ) {\n\tvar nu = cldr.attributes[ \"u-nu\" ];\n\n\tif ( nu ) {\n\t\tif ( nu === \"traditio\" ) {\n\t\t\tnu = \"traditional\";\n\t\t}\n\t\tif ( [ \"native\", \"traditional\", \"finance\" ].indexOf( nu ) !== -1 ) {\n\n\t\t\t// Unicode locale extension `u-nu` is set using either (native, traditional or\n\t\t\t// finance). So, lookup the respective locale's numberingSystem and return it.\n\t\t\treturn cldr.main([ \"numbers/otherNumberingSystems\", nu ]);\n\t\t}\n\n\t\t// Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.\n\t\treturn nu;\n\t}\n\n\t// Return the default numberingSystem.\n\treturn cldr.main( \"numbers/defaultNumberingSystem\" );\n};\n\n\n\n\n/**\n * nuMap( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return digits map if numbering system is different than `latn`.\n */\nvar numberNumberingSystemDigitsMap = function( cldr ) {\n\tvar aux,\n\t\tnu = numberNumberingSystem( cldr );\n\n\tif ( nu === \"latn\" ) {\n\t\treturn;\n\t}\n\n\taux = cldr.supplemental([ \"numberingSystems\", nu ]);\n\n\tif ( aux._type !== \"numeric\" ) {\n\t\tthrow createErrorUnsupportedFeature( \"`\" + aux._type + \"` numbering system\" );\n\t}\n\n\treturn aux._digits;\n};\n\n\n\n\n/**\n * EBNF representation:\n *\n * number_pattern_re =        prefix?\n *                            padding?\n *                            (integer_fraction_pattern | significant_pattern)\n *                            scientific_notation?\n *                            suffix?\n *\n * prefix =                   non_number_stuff\n *\n * padding =                  \"*\" regexp(.)\n *\n * integer_fraction_pattern = integer_pattern\n *                            fraction_pattern?\n *\n * integer_pattern =          regexp([#,]*[0,]*0+)\n *\n * fraction_pattern =         \".\" regexp(0*[0-9]*#*)\n *\n * significant_pattern =      regexp([#,]*@+#*)\n *\n * scientific_notation =      regexp(E\\+?0+)\n *\n * suffix =                   non_number_stuff\n *\n * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)\n *\n *\n * Regexp groups:\n *\n *  0: number_pattern_re\n *  1: prefix\n *  2: -\n *  3: -\n *  4: padding\n *  5: (integer_fraction_pattern | significant_pattern)\n *  6: integer_fraction_pattern\n *  7: integer_pattern\n *  8: fraction_pattern\n *  9: significant_pattern\n * 10: scientific_notation\n * 11: suffix\n * 12: -\n */\nvar numberPatternRe = ( /^(('([^']|'')*'|[^*#@0,.E])*)(\\*.)?((([#,]*[0,]*0+)(\\.0*[0-9]*#*)?)|([#,]*@+#*))(E\\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/ );\n\n\n\n\n/**\n * format( number, pattern )\n *\n * @number [Number].\n *\n * @pattern [String] raw pattern for numbers.\n *\n * Return the formatted number.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberPatternProperties = function( pattern ) {\n\tvar aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern,\n\t\tmaximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,\n\t\tminimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize,\n\t\troundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;\n\n\tpattern = pattern.match( numberPatternRe );\n\tif ( !pattern ) {\n\t\tthrow new Error( \"Invalid pattern: \" + pattern );\n\t}\n\n\tprefix = pattern[ 1 ];\n\tpadding = pattern[ 4 ];\n\tintegerFractionOrSignificantPattern = pattern[ 5 ];\n\tsignificantPattern = pattern[ 9 ];\n\tscientificNotation = pattern[ 10 ];\n\tsuffix = pattern[ 11 ];\n\n\t// Significant digit format\n\tif ( significantPattern ) {\n\t\tsignificantPattern.replace( /(@+)(#*)/, function( match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch ) {\n\t\t\tminimumSignificantDigits = minimumSignificantDigitsMatch.length;\n\t\t\tmaximumSignificantDigits = minimumSignificantDigits +\n\t\t\t\tmaximumSignificantDigitsMatch.length;\n\t\t});\n\n\t// Integer and fractional format\n\t} else {\n\t\tfractionPattern = pattern[ 8 ];\n\t\tintegerPattern = pattern[ 7 ];\n\n\t\tif ( fractionPattern ) {\n\n\t\t\t// Minimum fraction digits, and rounding.\n\t\t\tfractionPattern.replace( /[0-9]+/, function( match ) {\n\t\t\t\tminimumFractionDigits = match;\n\t\t\t});\n\t\t\tif ( minimumFractionDigits ) {\n\t\t\t\troundIncrement = +( \"0.\" + minimumFractionDigits );\n\t\t\t\tminimumFractionDigits = minimumFractionDigits.length;\n\t\t\t} else {\n\t\t\t\tminimumFractionDigits = 0;\n\t\t\t}\n\n\t\t\t// Maximum fraction digits\n\t\t\t// 1: ignore decimal character\n\t\t\tmaximumFractionDigits = fractionPattern.length - 1 /* 1 */;\n\t\t}\n\n\t\t// Minimum integer digits\n\t\tintegerPattern.replace( /0+$/, function( match ) {\n\t\t\tminimumIntegerDigits = match.length;\n\t\t});\n\t}\n\n\t// Scientific notation\n\tif ( scientificNotation ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"scientific notation (not implemented)\"\n\t\t});\n\t}\n\n\t// Padding\n\tif ( padding ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"padding (not implemented)\"\n\t\t});\n\t}\n\n\t// Grouping\n\tif ( ( aux1 = integerFractionOrSignificantPattern.lastIndexOf( \",\" ) ) !== -1 ) {\n\n\t\t// Primary grouping size is the interval between the last group separator and the end of\n\t\t// the integer (or the end of the significant pattern).\n\t\taux2 = integerFractionOrSignificantPattern.split( \".\" )[ 0 ];\n\t\tprimaryGroupingSize = aux2.length - aux1 - 1;\n\n\t\t// Secondary grouping size is the interval between the last two group separators.\n\t\tif ( ( aux2 = integerFractionOrSignificantPattern.lastIndexOf( \",\", aux1 - 1 ) ) !== -1 ) {\n\t\t\tsecondaryGroupingSize = aux1 - 1 - aux2;\n\t\t}\n\t}\n\n\t// Return:\n\t//  0: @prefix String\n\t//  1: @padding Array [ <character>, <count> ] TODO\n\t//  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer\n\t//        digits to be used. Numbers will be padded with leading zeroes if necessary.\n\t//  3: @minimumFractionDigits and\n\t//  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and\n\t//        maximum fraction digits to be used. Numbers will be rounded or padded with trailing\n\t//        zeroes if necessary.\n\t//  5: @minimumSignificantDigits and\n\t//  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and\n\t//        maximum fraction digits to be shown. Either none or both of these properties are\n\t//        present; if they are, they override minimum and maximum integer and fraction digits\n\t//        – the formatter uses however many integer and fraction digits are required to display\n\t//        the specified number of significant digits.\n\t//  7: @roundIncrement Decimal round increment or null\n\t//  8: @primaryGroupingSize\n\t//  9: @secondaryGroupingSize\n\t// 10: @suffix String\n\treturn [\n\t\tprefix,\n\t\tpadding,\n\t\tminimumIntegerDigits,\n\t\tminimumFractionDigits,\n\t\tmaximumFractionDigits,\n\t\tminimumSignificantDigits,\n\t\tmaximumSignificantDigits,\n\t\troundIncrement,\n\t\tprimaryGroupingSize,\n\t\tsecondaryGroupingSize,\n\t\tsuffix\n\t];\n};\n\n\n\n\n/**\n * Symbol( name, cldr )\n *\n * @name [String] Symbol name.\n *\n * @cldr [Cldr instance].\n *\n * Return the localized symbol given its name.\n */\nvar numberSymbol = function( name, cldr ) {\n\treturn cldr.main([\n\t\t\"numbers/symbols-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\tname\n\t]);\n};\n\n\n\n\nvar numberSymbolName = {\n\t\".\": \"decimal\",\n\t\",\": \"group\",\n\t\"%\": \"percentSign\",\n\t\"+\": \"plusSign\",\n\t\"-\": \"minusSign\",\n\t\"E\": \"exponential\",\n\t\"\\u2030\": \"perMille\"\n};\n\n\n\n\n/**\n * symbolMap( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return the (localized symbol, pattern symbol) key value pair, eg. {\n *   \".\": \"٫\",\n *   \",\": \"٬\",\n *   \"%\": \"٪\",\n *   ...\n * };\n */\nvar numberSymbolMap = function( cldr ) {\n\tvar symbol,\n\t\tsymbolMap = {};\n\n\tfor ( symbol in numberSymbolName ) {\n\t\tsymbolMap[ symbol ] = numberSymbol( numberSymbolName[ symbol ], cldr );\n\t}\n\n\treturn symbolMap;\n};\n\n\n\n\nvar numberTruncate = function( value ) {\n\tif ( isNaN( value ) ) {\n\t\treturn NaN;\n\t}\n\treturn Math[ value < 0 ? \"ceil\" : \"floor\" ]( value );\n};\n\n\n\n\n/**\n * round( method )\n *\n * @method [String] with either \"round\", \"ceil\", \"floor\", or \"truncate\".\n *\n * Return function( value, incrementOrExp ):\n *\n *   @value [Number] eg. 123.45.\n *\n *   @incrementOrExp [Number] optional, eg. 0.1; or\n *     [Object] Either { increment: <value> } or { exponent: <value> }\n *\n *   Return the rounded number, eg:\n *   - round( \"round\" )( 123.45 ): 123;\n *   - round( \"ceil\" )( 123.45 ): 124;\n *   - round( \"floor\" )( 123.45 ): 123;\n *   - round( \"truncate\" )( 123.45 ): 123;\n *   - round( \"round\" )( 123.45, 0.1 ): 123.5;\n *   - round( \"round\" )( 123.45, 10 ): 120;\n *\n *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n *   Ref: #376\n */\nvar numberRound = function( method ) {\n\tmethod = method || \"round\";\n\tmethod = method === \"truncate\" ? numberTruncate : Math[ method ];\n\n\treturn function( value, incrementOrExp ) {\n\t\tvar exp, increment;\n\n\t\tvalue = +value;\n\n\t\t// If the value is not a number, return NaN.\n\t\tif ( isNaN( value ) ) {\n\t\t\treturn NaN;\n\t\t}\n\n\t\t// Exponent given.\n\t\tif ( typeof incrementOrExp === \"object\" && incrementOrExp.exponent ) {\n\t\t\texp = +incrementOrExp.exponent;\n\t\t\tincrement = 1;\n\n\t\t\tif ( exp === 0 ) {\n\t\t\t\treturn method( value );\n\t\t\t}\n\n\t\t\t// If the exp is not an integer, return NaN.\n\t\t\tif ( !( typeof exp === \"number\" && exp % 1 === 0 ) ) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\n\t\t// Increment given.\n\t\t} else {\n\t\t\tincrement = +incrementOrExp || 1;\n\n\t\t\tif ( increment === 1 ) {\n\t\t\t\treturn method( value );\n\t\t\t}\n\n\t\t\t// If the increment is not a number, return NaN.\n\t\t\tif ( isNaN( increment ) ) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\n\t\t\tincrement = increment.toExponential().split( \"e\" );\n\t\t\texp = +increment[ 1 ];\n\t\t\tincrement = +increment[ 0 ];\n\t\t}\n\n\t\t// Shift & Round\n\t\tvalue = value.toString().split( \"e\" );\n\t\tvalue[ 0 ] = +value[ 0 ] / increment;\n\t\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] - exp ) : -exp;\n\t\tvalue = method( +( value[ 0 ] + \"e\" + value[ 1 ] ) );\n\n\t\t// Shift back\n\t\tvalue = value.toString().split( \"e\" );\n\t\tvalue[ 0 ] = +value[ 0 ] * increment;\n\t\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] + exp ) : exp;\n\t\treturn +( value[ 0 ] + \"e\" + value[ 1 ] );\n\t};\n};\n\n\n\n\n/**\n * formatProperties( pattern, cldr [, options] )\n *\n * @pattern [String] raw pattern for numbers.\n *\n * @cldr [Cldr instance].\n *\n * @options [Object]:\n * - minimumIntegerDigits [Number]\n * - minimumFractionDigits, maximumFractionDigits [Number]\n * - minimumSignificantDigits, maximumSignificantDigits [Number]\n * - round [String] \"ceil\", \"floor\", \"round\" (default), or \"truncate\".\n * - useGrouping [Boolean] default true.\n *\n * Return the processed properties that will be used in number/format.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberFormatProperties = function( pattern, cldr, options ) {\n\tvar negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern,\n\t\troundFn, properties;\n\n\tfunction getOptions( attribute, propertyIndex ) {\n\t\tif ( attribute in options ) {\n\t\t\tproperties[ propertyIndex ] = options[ attribute ];\n\t\t}\n\t}\n\n\toptions = options || {};\n\tpattern = pattern.split( \";\" );\n\n\tpositivePattern = pattern[ 0 ];\n\n\tnegativePattern = pattern[ 1 ] || \"-\" + positivePattern;\n\tnegativeProperties = numberPatternProperties( negativePattern );\n\tnegativePrefix = negativeProperties[ 0 ];\n\tnegativeSuffix = negativeProperties[ 10 ];\n\n\t// Have runtime code to refer to numberRound() instead of including it explicitly.\n\troundFn = numberRound( options.round );\n\troundFn.generatorString = function() {\n\t\treturn \"numberRound(\" + ( options.round ? \"\\\"\" + options.round + \"\\\"\" : \"\" ) + \")\";\n\t};\n\n\tproperties = numberPatternProperties( positivePattern ).concat([\n\t\tpositivePattern,\n\t\tnegativePrefix + positivePattern + negativeSuffix,\n\t\tnegativePrefix,\n\t\tnegativeSuffix,\n\t\troundFn,\n\t\tnumberSymbol( \"infinity\", cldr ),\n\t\tnumberSymbol( \"nan\", cldr ),\n\t\tnumberSymbolMap( cldr ),\n\t\tnumberNumberingSystemDigitsMap( cldr )\n\t]);\n\n\tgetOptions( \"minimumIntegerDigits\", 2 );\n\tgetOptions( \"minimumFractionDigits\", 3 );\n\tgetOptions( \"maximumFractionDigits\", 4 );\n\tgetOptions( \"minimumSignificantDigits\", 5 );\n\tgetOptions( \"maximumSignificantDigits\", 6 );\n\n\t// Grouping separators\n\tif ( options.useGrouping === false ) {\n\t\tproperties[ 8 ] = null;\n\t}\n\n\t// Normalize number of digits if only one of either minimumFractionDigits or\n\t// maximumFractionDigits is passed in as an option\n\tif ( \"minimumFractionDigits\" in options && !( \"maximumFractionDigits\" in options ) ) {\n\n\t\t// maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );\n\t\tproperties[ 4 ] = Math.max( properties[ 3 ], properties[ 4 ] );\n\t} else if ( !( \"minimumFractionDigits\" in options ) &&\n\t\t\t\"maximumFractionDigits\" in options ) {\n\n\t\t// minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );\n\t\tproperties[ 3 ] = Math.min( properties[ 3 ], properties[ 4 ] );\n\t}\n\n\t// Return:\n\t// 0-10: see number/pattern-properties.\n\t// 11: @positivePattern [String] Positive pattern.\n\t// 12: @negativePattern [String] Negative pattern.\n\t// 13: @negativePrefix [String] Negative prefix.\n\t// 14: @negativeSuffix [String] Negative suffix.\n\t// 15: @round [Function] Round function.\n\t// 16: @infinitySymbol [String] Infinity symbol.\n\t// 17: @nanSymbol [String] NaN symbol.\n\t// 18: @symbolMap [Object] A bunch of other symbols.\n\t// 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.\n\treturn properties;\n};\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var formatSymbols = require( * \"unicode-8.0.0/General_Category/Format/symbols\" );\n * regenerate().add( formatSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-8.0.0\n */\nvar regexpCfG = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/g;\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var dashSymbols = require( * \"unicode-8.0.0/General_Category/Dash_Punctuation/symbols\" );\n * regenerate().add( dashSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-8.0.0\n *\n * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.\n */\nvar regexpDashG = /[\\-\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D\\u2212]/g;\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var spaceSeparatorSymbols = require( \"unicode-8.0.0/General_Category/Space_Separator/symbols\" );\n * regenerate().add( spaceSeparatorSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-8.0.0\n */\nvar regexpZsG = /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g;\n\n\n\n\n/**\n * parse( value, properties )\n *\n * @value [String].\n *\n * @properties [Object] Parser properties is a reduced pre-processed cldr\n * data set returned by numberParserProperties().\n *\n * Return the parsed Number (including Infinity) or NaN when value is invalid.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberParse = function( value, properties ) {\n\tvar grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix,\n\t\tsuffix, tokenizer, valid;\n\n\t// Grammar:\n\t// - Value <=           NaN | PositiveNumber | NegativeNumber\n\t// - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix\n\t// - NegativeNumber <=  NegativePrefix NumberOrInf\n\t// - NumberOrInf <=     Number | Inf\n\tgrammar = [\n\t\t[ \"nan\" ],\n\t\t[ \"prefix\", \"infinity\", \"suffix\" ],\n\t\t[ \"prefix\", \"number\", \"suffix\" ],\n\t\t[ \"negativePrefix\", \"infinity\", \"negativeSuffix\" ],\n\t\t[ \"negativePrefix\", \"number\", \"negativeSuffix\" ]\n\t];\n\n\tinvertedSymbolMap = properties[ 0 ];\n\tinvertedNuDigitsMap = properties[ 1 ] || {};\n\ttokenizer = properties[ 2 ];\n\n\t// Loose Matching:\n\t// - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\n\t//   formatting.\n\t// - Map all characters in [:Zs:] to U+0020 SPACE;\n\t// - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\n\tvalue = value\n\t\t.replace( regexpCfG, \"\" )\n\t\t.replace( regexpDashG, \"-\" )\n\t\t.replace( regexpZsG, \" \" );\n\n\tfunction parse( type ) {\n\t\treturn function( lexeme ) {\n\n\t\t\t// Reverse localized symbols and numbering system.\n\t\t\tlexeme = lexeme.split( \"\" ).map(function( character ) {\n\t\t\t\treturn invertedSymbolMap[ character ] ||\n\t\t\t\t\tinvertedNuDigitsMap[ character ] ||\n\t\t\t\t\tcharacter;\n\t\t\t}).join( \"\" );\n\n\t\t\tswitch ( type ) {\n\t\t\t\tcase \"infinity\":\n\t\t\t\t\tnumber = Infinity;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"nan\":\n\t\t\t\t\tnumber = NaN;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"number\":\n\n\t\t\t\t\t// Remove grouping separators.\n\t\t\t\t\tlexeme = lexeme.replace( /,/g, \"\" );\n\n\t\t\t\t\tnumber = +lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"prefix\":\n\t\t\t\tcase \"negativePrefix\":\n\t\t\t\t\tprefix = lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"suffix\":\n\t\t\t\t\tsuffix = lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"negativeSuffix\":\n\t\t\t\t\tsuffix = lexeme;\n\t\t\t\t\tnegative = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// This should never be reached.\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( \"Internal error\" );\n\t\t\t}\n\t\t\treturn \"\";\n\t\t};\n\t}\n\n\tfunction tokenizeNParse( _value, grammar ) {\n\t\treturn grammar.some(function( statement ) {\n\t\t\tvar value = _value;\n\n\t\t\t// The whole grammar statement should be used (i.e., .every() return true) and value be\n\t\t\t// entirely consumed (i.e., !value.length).\n\t\t\treturn statement.every(function( type ) {\n\t\t\t\tif ( value.match( tokenizer[ type ] ) === null ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Consume and parse it.\n\t\t\t\tvalue = value.replace( tokenizer[ type ], parse( type ) );\n\t\t\t\treturn true;\n\t\t\t}) && !value.length;\n\t\t});\n\t}\n\n\tvalid = tokenizeNParse( value, grammar );\n\n\t// NaN\n\tif ( !valid || isNaN( number ) ) {\n\t\treturn NaN;\n\t}\n\n\tprefixNSuffix = \"\" + prefix + suffix;\n\n\t// Percent\n\tif ( prefixNSuffix.indexOf( \"%\" ) !== -1 ) {\n\t\tnumber /= 100;\n\n\t// Per mille\n\t} else if ( prefixNSuffix.indexOf( \"\\u2030\" ) !== -1 ) {\n\t\tnumber /= 1000;\n\t}\n\n\t// Negative number\n\tif ( negative ) {\n\t\tnumber *= -1;\n\t}\n\n\treturn number;\n};\n\n\n\n\nvar numberParserFn = function( properties ) {\n\treturn function numberParser( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeString( value, \"value\" );\n\n\t\treturn numberParse( value, properties );\n\t};\n\n};\n\n\n\n\n/**\n * symbolMap( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return the (localized symbol, pattern symbol) key value pair, eg. {\n *   \"٫\": \".\",\n *   \"٬\": \",\",\n *   \"٪\": \"%\",\n *   ...\n * };\n */\nvar numberSymbolInvertedMap = function( cldr ) {\n\tvar symbol,\n\t\tsymbolMap = {};\n\n\tfor ( symbol in numberSymbolName ) {\n\t\tsymbolMap[ numberSymbol( numberSymbolName[ symbol ], cldr ) ] = symbol;\n\t}\n\n\treturn symbolMap;\n};\n\n\n\n\n/**\n * objectMap( object, fn)\n *\n * - object\n *\n * - fn( pair ) => pair\n */\nvar objectMap = function( object, fn ) {\n\treturn Object.keys( object ).map(function( key ) {\n\t\treturn fn([ key, object[ key ] ]);\n\t}).reduce(function( object, pair ) {\n\t\tobject[ pair[ 0 ] ] = pair[ 1 ];\n\t\treturn object;\n\t}, {});\n};\n\n\n\n\n/**\n * parseProperties( pattern, cldr )\n *\n * @pattern [String] raw pattern for numbers.\n *\n * @cldr [Cldr instance].\n *\n * Return parser properties, used to feed parser function.\n *\n * TODO:\n * - Scientific_notation;\n * - Padding;\n */\nvar numberParseProperties = function( pattern, cldr, options ) {\n\tvar aux, decimalSymbolRe, digitsRe, groupingSeparatorRe, infinitySymbol, invertedNuDigitsMap,\n\t\tinvertedSymbolMap, maximumFractionDigits, maximumSignificantDigits,\n\t\tminimumSignificantDigits, nanSymbol, negativePrefix, negativeSuffix, nuDigitsMap,\n\t\tnumberTokenizer, prefix, primaryGroupingSize, secondaryGroupingSize, suffix, symbolMap,\n\t\tformatProperties = numberFormatProperties( pattern, cldr, options );\n\n\t// Loose Matching:\n\t// - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\n\t//   formatting.\n\t// - Map all characters in [:Zs:] to U+0020 SPACE;\n\t// - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\n\tfunction looseMatching( value ) {\n\t\treturn value\n\t\t\t.replace( regexpCfG, \"\" )\n\t\t\t.replace( regexpDashG, \"-\" )\n\t\t\t.replace( regexpZsG, \" \" );\n\t}\n\n\tprefix = looseMatching( formatProperties[ 0 ] );\n\tmaximumFractionDigits = formatProperties[ 4 ];\n\tminimumSignificantDigits = formatProperties[ 5 ];\n\tmaximumSignificantDigits = formatProperties[ 6 ];\n\tprimaryGroupingSize = formatProperties[ 8 ];\n\tsecondaryGroupingSize = formatProperties[ 9 ];\n\tsuffix = looseMatching( formatProperties[ 10 ] );\n\tnegativePrefix = looseMatching( formatProperties[ 13 ] );\n\tnegativeSuffix = looseMatching( formatProperties[ 14 ] );\n\tinfinitySymbol = looseMatching( formatProperties[ 16 ] );\n\tnanSymbol = looseMatching( formatProperties[ 17 ] );\n\tsymbolMap = objectMap( formatProperties[ 18 ], function( pair ) {\n\t\treturn [ pair[ 0 ], looseMatching( pair[ 1 ] ) ];\n\t});\n\tnuDigitsMap = formatProperties[ 19 ];\n\n\tinvertedSymbolMap = objectMap( numberSymbolInvertedMap( cldr ), function( pair ) {\n\t\treturn [ looseMatching( pair[ 0 ] ), pair[ 1 ] ];\n\t});\n\n\tdigitsRe = nuDigitsMap ? \"[\" + nuDigitsMap + \"]\" : \"\\\\d\";\n\tgroupingSeparatorRe = regexpEscape( symbolMap[ \",\" ] );\n\tdecimalSymbolRe = regexpEscape( symbolMap[ \".\" ] );\n\n\tif ( nuDigitsMap ) {\n\t\tinvertedNuDigitsMap = nuDigitsMap.split( \"\" ).reduce(function( object, localizedDigit, i ) {\n\t\t\tobject[ localizedDigit ] = String( i );\n\t\t\treturn object;\n\t\t}, {} );\n\t}\n\n\taux = [ prefix, suffix, negativePrefix, negativeSuffix ].map(function( value ) {\n\t\treturn value.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {\n\n\t\t\t// Literals\n\t\t\tif ( literal ) {\n\t\t\t\treturn removeLiteralQuotes( literal );\n\t\t\t}\n\n\t\t\t// Symbols\n\t\t\tcharacter = character.replace( /[\\-+E%\\u2030]/, function( symbol ) {\n\t\t\t\treturn symbolMap[ symbol ];\n\t\t\t});\n\n\t\t\treturn character;\n\t\t});\n\t});\n\n\tprefix = aux[ 0 ];\n\tsuffix = aux[ 1 ];\n\tnegativePrefix = aux[ 2 ];\n\tnegativeSuffix = aux[ 3 ];\n\n\t// Number\n\t//\n\t// number_re =                       integer fraction?\n\t//\n\t// integer =                         digits | digits_using_grouping_separators\n\t//\n\t// fraction =                        regexp((.\\d+)?)\n\t//\n\t// digits =                          regexp(\\d+)\n\t//\n\t// digits_w_grouping_separators =    digits_w_1_grouping_separators |\n\t//                                   digits_w_2_grouping_separators\n\t//\n\t// digits_w_1_grouping_separators =  regexp(\\d{1,3}(,\\d{3})+)\n\t//\n\t// digits_w_2_grouping_separators =  regexp(\\d{1,2}((,\\d{2})*(,\\d{3})))\n\n\t// Integer part\n\tnumberTokenizer = digitsRe + \"+\";\n\n\t// Grouping separators\n\tif ( primaryGroupingSize ) {\n\t\tif ( secondaryGroupingSize ) {\n\t\t\taux = digitsRe + \"{1,\" + secondaryGroupingSize + \"}((\" + groupingSeparatorRe +\n\t\t\t\tdigitsRe + \"{\" + secondaryGroupingSize + \"})*(\" + groupingSeparatorRe +\n\t\t\t\tdigitsRe + \"{\" + primaryGroupingSize + \"}))\";\n\t\t} else {\n\t\t\taux = digitsRe + \"{1,\" + primaryGroupingSize + \"}(\" + groupingSeparatorRe +\n\t\t\t\tdigitsRe + \"{\" + primaryGroupingSize + \"})+\";\n\t\t}\n\t\tnumberTokenizer = \"(\" + aux + \"|\" + numberTokenizer + \")\";\n\t}\n\n\t// Fraction part? Only included if 1 or 2.\n\t// 1: Using significant digit format.\n\t// 2: Using integer and fractional format && it has a maximumFractionDigits.\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) || /* 1 */\n\t\t\t\tmaximumFractionDigits /* 2 */ ) {\n\n\t\taux = decimalSymbolRe + digitsRe + \"+\";\n\t\tnumberTokenizer = numberTokenizer + \"(\" + aux + \")?\" +\n\n\t\t\t// Handle non-padded decimals, e.g., `\".12\"` => `0.12` by making the integer part\n\t\t\t// optional.\n\t\t\t\"|(\" + numberTokenizer + \")?\" + aux;\n\n\t\tnumberTokenizer = \"(\" + numberTokenizer + \")\";\n\t}\n\n\t// 0: @invertedSymbolMap [Object] Inverted symbol map.\n\t// 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than\n\t//    `latn`.\n\t// 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.\n\treturn [\n\t\tinvertedSymbolMap,\n\t\tinvertedNuDigitsMap,\n\t\t{\n\t\t\tinfinity: new RegExp( \"^\" + regexpEscape( infinitySymbol ) ),\n\t\t\tnan:  new RegExp( \"^\" + regexpEscape( nanSymbol ) ),\n\t\t\tnegativePrefix: new RegExp( \"^\" + regexpEscape( negativePrefix ) ),\n\t\t\tnegativeSuffix: new RegExp( \"^\" + regexpEscape( negativeSuffix ) ),\n\t\t\tnumber: new RegExp( \"^\" + numberTokenizer ),\n\t\t\tprefix: new RegExp( \"^\" + regexpEscape( prefix ) ),\n\t\t\tsuffix: new RegExp( \"^\" + regexpEscape( suffix ) )\n\t\t}\n\t];\n\n};\n\n\n\n\n/**\n * Pattern( style )\n *\n * @style [String] \"decimal\" (default) or \"percent\".\n *\n * @cldr [Cldr instance].\n */\nvar numberPattern = function( style, cldr ) {\n\tif ( style !== \"decimal\" && style !== \"percent\" ) {\n\t\tthrow new Error( \"Invalid style\" );\n\t}\n\n\treturn cldr.main([\n\t\t\"numbers\",\n\t\tstyle + \"Formats-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\t\"standard\"\n\t]);\n};\n\n\n\n\nfunction validateDigits( properties ) {\n\tvar minimumIntegerDigits = properties[ 2 ],\n\t\tminimumFractionDigits = properties[ 3 ],\n\t\tmaximumFractionDigits = properties[ 4 ],\n\t\tminimumSignificantDigits = properties[ 5 ],\n\t\tmaximumSignificantDigits = properties[ 6 ];\n\n\t// Validate significant digit format properties\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {\n\t\tvalidateParameterRange( minimumSignificantDigits, \"minimumSignificantDigits\", 1, 21 );\n\t\tvalidateParameterRange( maximumSignificantDigits, \"maximumSignificantDigits\",\n\t\t\tminimumSignificantDigits, 21 );\n\n\t} else if ( !isNaN( minimumSignificantDigits ) || !isNaN( maximumSignificantDigits ) ) {\n\t\tthrow new Error( \"Neither or both the minimum and maximum significant digits must be \" +\n\t\t\t\"present\" );\n\n\t// Validate integer and fractional format\n\t} else {\n\t\tvalidateParameterRange( minimumIntegerDigits, \"minimumIntegerDigits\", 1, 21 );\n\t\tvalidateParameterRange( minimumFractionDigits, \"minimumFractionDigits\", 0, 20 );\n\t\tvalidateParameterRange( maximumFractionDigits, \"maximumFractionDigits\",\n\t\t\tminimumFractionDigits, 20 );\n\t}\n}\n\n/**\n * .numberFormatter( [options] )\n *\n * @options [Object]:\n * - style: [String] \"decimal\" (default) or \"percent\".\n * - see also number/format options.\n *\n * Return a function that formats a number according to the given options and default/instance\n * locale.\n */\nGlobalize.numberFormatter =\nGlobalize.prototype.numberFormatter = function( options ) {\n\tvar args, cldr, pattern, properties, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\tcldr = this.cldr;\n\n\targs = [ options ];\n\n\tvalidateDefaultLocale( cldr );\n\n\tcldr.on( \"get\", validateCldr );\n\n\tif ( options.raw ) {\n\t\tpattern = options.raw;\n\t} else {\n\t\tpattern = numberPattern( options.style || \"decimal\", cldr );\n\t}\n\n\tproperties = numberFormatProperties( pattern, cldr, options );\n\n\tcldr.off( \"get\", validateCldr );\n\n\tvalidateDigits( properties );\n\n\treturnFn = numberFormatterFn( properties );\n\n\truntimeBind( args, cldr, returnFn, [ properties ] );\n\n\treturn returnFn;\n};\n\n/**\n * .numberParser( [options] )\n *\n * @options [Object]:\n * - style: [String] \"decimal\" (default) or \"percent\".\n *\n * Return the number parser according to the default/instance locale.\n */\nGlobalize.numberParser =\nGlobalize.prototype.numberParser = function( options ) {\n\tvar args, cldr, pattern, properties, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\tcldr = this.cldr;\n\n\targs = [ options ];\n\n\tvalidateDefaultLocale( cldr );\n\n\tcldr.on( \"get\", validateCldr );\n\n\tif ( options.raw ) {\n\t\tpattern = options.raw;\n\t} else {\n\t\tpattern = numberPattern( options.style || \"decimal\", cldr );\n\t}\n\n\tproperties = numberParseProperties( pattern, cldr, options );\n\n\tcldr.off( \"get\", validateCldr );\n\n\treturnFn = numberParserFn( properties );\n\n\truntimeBind( args, cldr, returnFn, [ properties ] );\n\n\treturn returnFn;\n};\n\n/**\n * .formatNumber( value [, options] )\n *\n * @value [Number] number to be formatted.\n *\n * @options [Object]: see number/format-properties.\n *\n * Format a number according to the given options and default/instance locale.\n */\nGlobalize.formatNumber =\nGlobalize.prototype.formatNumber = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\n\treturn this.numberFormatter( options )( value );\n};\n\n/**\n * .parseNumber( value [, options] )\n *\n * @value [String]\n *\n * @options [Object]: See numberParser().\n *\n * Return the parsed Number (including Infinity) or NaN when value is invalid.\n */\nGlobalize.parseNumber =\nGlobalize.prototype.parseNumber = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeString( value, \"value\" );\n\n\treturn this.numberParser( options )( value );\n};\n\n/**\n * Optimization to avoid duplicating some internal functions across modules.\n */\nGlobalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;\nGlobalize._numberNumberingSystem = numberNumberingSystem;\nGlobalize._numberPattern = numberPattern;\nGlobalize._numberSymbol = numberSymbol;\nGlobalize._removeLiteralQuotes = removeLiteralQuotes;\nGlobalize._stringPad = stringPad;\nGlobalize._validateParameterTypeNumber = validateParameterTypeNumber;\nGlobalize._validateParameterTypeString = validateParameterTypeString;\n\nreturn Globalize;\n\n\n\n\n}));\n","/home/travis/build/npmtest/node-npmtest-globalize/node_modules/globalize/dist/globalize/plural.js":"/**\n * Globalize v1.2.3\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2017-03-17T01:41Z\n */\n/*!\n * Globalize v1.2.3 2017-03-17T01:41Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"cldr/event\",\n\t\t\t\"cldr/supplemental\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar runtimeBind = Globalize._runtimeBind,\n\tvalidateCldr = Globalize._validateCldr,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\nvar MakePlural;\n/* jshint ignore:start */\nMakePlural = (function() {\n'use strict';\n\nvar _toArray = function (arr) { return Array.isArray(arr) ? arr : Array.from(arr); };\n\nvar _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n\n/**\n * make-plural.js -- https://github.com/eemeli/make-plural.js/\n * Copyright (c) 2014-2015 by Eemeli Aro <eemeli@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * The software is provided \"as is\" and the author disclaims all warranties\n * with regard to this software including all implied warranties of\n * merchantability and fitness. In no event shall the author be liable for\n * any special, direct, indirect, or consequential damages or any damages\n * whatsoever resulting from loss of use, data or profits, whether in an\n * action of contract, negligence or other tortious action, arising out of\n * or in connection with the use or performance of this software.\n */\n\nvar Parser = (function () {\n    function Parser() {\n        _classCallCheck(this, Parser);\n    }\n\n    _createClass(Parser, [{\n        key: 'parse',\n        value: function parse(cond) {\n            var _this = this;\n\n            if (cond === 'i = 0 or n = 1') {\n                return 'n >= 0 && n <= 1';\n            }if (cond === 'i = 0,1') {\n                return 'n >= 0 && n < 2';\n            }if (cond === 'i = 1 and v = 0') {\n                this.v0 = 1;\n                return 'n == 1 && v0';\n            }\n            return cond.replace(/([tv]) (!?)= 0/g, function (m, sym, noteq) {\n                var sn = sym + '0';\n                _this[sn] = 1;\n                return noteq ? '!' + sn : sn;\n            }).replace(/\\b[fintv]\\b/g, function (m) {\n                _this[m] = 1;\n                return m;\n            }).replace(/([fin]) % (10+)/g, function (m, sym, num) {\n                var sn = sym + num;\n                _this[sn] = 1;\n                return sn;\n            }).replace(/n10+ = 0/g, 't0 && $&').replace(/(\\w+ (!?)= )([0-9.]+,[0-9.,]+)/g, function (m, se, noteq, x) {\n                if (m === 'n = 0,1') return '(n == 0 || n == 1)';\n                if (noteq) return se + x.split(',').join(' && ' + se);\n                return '(' + se + x.split(',').join(' || ' + se) + ')';\n            }).replace(/(\\w+) (!?)= ([0-9]+)\\.\\.([0-9]+)/g, function (m, sym, noteq, x0, x1) {\n                if (Number(x0) + 1 === Number(x1)) {\n                    if (noteq) return '' + sym + ' != ' + x0 + ' && ' + sym + ' != ' + x1;\n                    return '(' + sym + ' == ' + x0 + ' || ' + sym + ' == ' + x1 + ')';\n                }\n                if (noteq) return '(' + sym + ' < ' + x0 + ' || ' + sym + ' > ' + x1 + ')';\n                if (sym === 'n') {\n                    _this.t0 = 1;return '(t0 && n >= ' + x0 + ' && n <= ' + x1 + ')';\n                }\n                return '(' + sym + ' >= ' + x0 + ' && ' + sym + ' <= ' + x1 + ')';\n            }).replace(/ and /g, ' && ').replace(/ or /g, ' || ').replace(/ = /g, ' == ');\n        }\n    }, {\n        key: 'vars',\n        value: (function (_vars) {\n            function vars() {\n                return _vars.apply(this, arguments);\n            }\n\n            vars.toString = function () {\n                return _vars.toString();\n            };\n\n            return vars;\n        })(function () {\n            var vars = [];\n            if (this.i) vars.push('i = s[0]');\n            if (this.f || this.v) vars.push('f = s[1] || \\'\\'');\n            if (this.t) vars.push('t = (s[1] || \\'\\').replace(/0+$/, \\'\\')');\n            if (this.v) vars.push('v = f.length');\n            if (this.v0) vars.push('v0 = !s[1]');\n            if (this.t0 || this.n10 || this.n100) vars.push('t0 = Number(s[0]) == n');\n            for (var k in this) {\n                if (/^.10+$/.test(k)) {\n                    var k0 = k[0] === 'n' ? 't0 && s[0]' : k[0];\n                    vars.push('' + k + ' = ' + k0 + '.slice(-' + k.substr(2).length + ')');\n                }\n            }if (!vars.length) return '';\n            return 'var ' + ['s = String(n).split(\\'.\\')'].concat(vars).join(', ');\n        })\n    }]);\n\n    return Parser;\n})();\n\n\n\nvar MakePlural = (function () {\n    function MakePlural(lc) {\n        var _ref = arguments[1] === undefined ? MakePlural : arguments[1];\n\n        var cardinals = _ref.cardinals;\n        var ordinals = _ref.ordinals;\n\n        _classCallCheck(this, MakePlural);\n\n        if (!cardinals && !ordinals) throw new Error('At least one type of plural is required');\n        this.lc = lc;\n        this.categories = { cardinal: [], ordinal: [] };\n        this.parser = new Parser();\n        \n        this.fn = this.buildFunction(cardinals, ordinals);\n        this.fn._obj = this;\n        this.fn.categories = this.categories;\n        \n        this.fn.toString = this.fnToString.bind(this);\n        return this.fn;\n    }\n\n    _createClass(MakePlural, [{\n        key: 'compile',\n        value: function compile(type, req) {\n            var cases = [];\n            var rules = MakePlural.rules[type][this.lc];\n            if (!rules) {\n                if (req) throw new Error('Locale \"' + this.lc + '\" ' + type + ' rules not found');\n                this.categories[type] = ['other'];\n                return '\\'other\\'';\n            }\n            for (var r in rules) {\n                var _rules$r$trim$split = rules[r].trim().split(/\\s*@\\w*/);\n\n                var _rules$r$trim$split2 = _toArray(_rules$r$trim$split);\n\n                var cond = _rules$r$trim$split2[0];\n                var examples = _rules$r$trim$split2.slice(1);\n                var cat = r.replace('pluralRule-count-', '');\n                if (cond) cases.push([this.parser.parse(cond), cat]);\n                \n            }\n            this.categories[type] = cases.map(function (c) {\n                return c[1];\n            }).concat('other');\n            if (cases.length === 1) {\n                return '(' + cases[0][0] + ') ? \\'' + cases[0][1] + '\\' : \\'other\\'';\n            } else {\n                return [].concat(_toConsumableArray(cases.map(function (c) {\n                    return '(' + c[0] + ') ? \\'' + c[1] + '\\'';\n                })), ['\\'other\\'']).join('\\n      : ');\n            }\n        }\n    }, {\n        key: 'buildFunction',\n        value: function buildFunction(cardinals, ordinals) {\n            var _this3 = this;\n\n            var compile = function compile(c) {\n                return c ? (c[1] ? 'return ' : 'if (ord) return ') + _this3.compile.apply(_this3, _toConsumableArray(c)) : '';\n            },\n                fold = { vars: function vars(str) {\n                    return ('  ' + str + ';').replace(/(.{1,78})(,|$) ?/g, '$1$2\\n      ');\n                },\n                cond: function cond(str) {\n                    return ('  ' + str + ';').replace(/(.{1,78}) (\\|\\| |$) ?/gm, '$1\\n          $2');\n                } },\n                cond = [ordinals && ['ordinal', !cardinals], cardinals && ['cardinal', true]].map(compile).map(fold.cond),\n                body = [fold.vars(this.parser.vars())].concat(_toConsumableArray(cond)).join('\\n').replace(/\\s+$/gm, '').replace(/^[\\s;]*[\\r\\n]+/gm, ''),\n                args = ordinals && cardinals ? 'n, ord' : 'n';\n            return new Function(args, body);\n        }\n    }, {\n        key: 'fnToString',\n        value: function fnToString(name) {\n            return Function.prototype.toString.call(this.fn).replace(/^function( \\w+)?/, name ? 'function ' + name : 'function').replace('\\n/**/', '');\n        }\n    }], [{\n        key: 'load',\n        value: function load() {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            args.forEach(function (cldr) {\n                var data = cldr && cldr.supplemental || null;\n                if (!data) throw new Error('Data does not appear to be CLDR data');\n                MakePlural.rules = {\n                    cardinal: data['plurals-type-cardinal'] || MakePlural.rules.cardinal,\n                    ordinal: data['plurals-type-ordinal'] || MakePlural.rules.ordinal\n                };\n            });\n            return MakePlural;\n        }\n    }]);\n\n    return MakePlural;\n})();\n\n\n\nMakePlural.cardinals = true;\nMakePlural.ordinals = false;\nMakePlural.rules = { cardinal: {}, ordinal: {} };\n\n\nreturn MakePlural;\n}());\n/* jshint ignore:end */\n\n\nvar validateParameterTypeNumber = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"number\",\n\t\t\"Number\"\n\t);\n};\n\n\n\n\nvar validateParameterTypePluralType = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || value === \"cardinal\" || value === \"ordinal\",\n\t\t\"String \\\"cardinal\\\" or \\\"ordinal\\\"\"\n\t);\n};\n\n\n\n\nvar pluralGeneratorFn = function( plural ) {\n\treturn function pluralGenerator( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeNumber( value, \"value\" );\n\n\t\treturn plural( value );\n\t};\n};\n\n\n\n\n/**\n * .plural( value )\n *\n * @value [Number]\n *\n * Return the corresponding form (zero | one | two | few | many | other) of a\n * value given locale.\n */\nGlobalize.plural =\nGlobalize.prototype.plural = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\treturn this.pluralGenerator( options )( value );\n};\n\n/**\n * .pluralGenerator( [options] )\n *\n * Return a plural function (of the form below).\n *\n * fn( value )\n *\n * @value [Number]\n *\n * Return the corresponding form (zero | one | two | few | many | other) of a value given the\n * default/instance locale.\n */\nGlobalize.pluralGenerator =\nGlobalize.prototype.pluralGenerator = function( options ) {\n\tvar args, cldr, isOrdinal, plural, returnFn, type;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\tcldr = this.cldr;\n\n\targs = [ options ];\n\ttype = options.type || \"cardinal\";\n\n\tvalidateParameterTypePluralType( options.type, \"options.type\" );\n\n\tvalidateDefaultLocale( cldr );\n\n\tisOrdinal = type === \"ordinal\";\n\n\tcldr.on( \"get\", validateCldr );\n\tcldr.supplemental([ \"plurals-type-\" + type, \"{language}\" ]);\n\tcldr.off( \"get\", validateCldr );\n\n\tMakePlural.rules = {};\n\tMakePlural.rules[ type ] = cldr.supplemental( \"plurals-type-\" + type );\n\n\tplural = new MakePlural( cldr.attributes.language, {\n\t\t\"ordinals\": isOrdinal,\n\t\t\"cardinals\": !isOrdinal\n\t});\n\n\treturnFn = pluralGeneratorFn( plural );\n\n\truntimeBind( args, cldr, returnFn, [ plural ] );\n\n\treturn returnFn;\n};\n\nreturn Globalize;\n\n\n\n\n}));\n","/home/travis/build/npmtest/node-npmtest-globalize/node_modules/globalize/dist/globalize/currency.js":"/*!\n * Globalize v1.2.3\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2017-03-17T01:41Z\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"./number\",\n\t\t\t\"cldr/event\",\n\t\t\t\"cldr/supplemental\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar alwaysArray = Globalize._alwaysArray,\n\tformatMessage = Globalize._formatMessage,\n\tnumberNumberingSystem = Globalize._numberNumberingSystem,\n\tnumberPattern = Globalize._numberPattern,\n\truntimeBind = Globalize._runtimeBind,\n\tstringPad = Globalize._stringPad,\n\tvalidateCldr = Globalize._validateCldr,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypeNumber = Globalize._validateParameterTypeNumber,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n\n\nvar validateParameterTypeCurrency = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"string\" && ( /^[A-Za-z]{3}$/ ).test( value ),\n\t\t\"3-letter currency code string as defined by ISO 4217\"\n\t);\n};\n\n\n\n\n/**\n * supplementalOverride( currency, pattern, cldr )\n *\n * Return pattern with fraction digits overriden by supplemental currency data.\n */\nvar currencySupplementalOverride = function( currency, pattern, cldr ) {\n\tvar digits,\n\t\tfraction = \"\",\n\t\tfractionData = cldr.supplemental([ \"currencyData/fractions\", currency ]) ||\n\t\t\tcldr.supplemental( \"currencyData/fractions/DEFAULT\" );\n\n\tdigits = +fractionData._digits;\n\n\tif ( digits ) {\n\t\tfraction = \".\" + stringPad( \"0\", digits ).slice( 0, -1 ) + fractionData._rounding;\n\t}\n\n\treturn pattern.replace( /\\.(#+|0*[0-9]|0+[0-9]?)/g, fraction );\n};\n\n\n\n\nvar objectFilter = function( object, testRe ) {\n\tvar key,\n\t\tcopy = {};\n\n\tfor ( key in object ) {\n\t\tif ( testRe.test( key ) ) {\n\t\t\tcopy[ key ] = object[ key ];\n\t\t}\n\t}\n\n\treturn copy;\n};\n\n\n\n\nvar currencyUnitPatterns = function( cldr ) {\n\treturn objectFilter( cldr.main([\n\t\t\"numbers\",\n\t\t\"currencyFormats-numberSystem-\" + numberNumberingSystem( cldr )\n\t]), /^unitPattern/ );\n};\n\n\n\n\n/**\n * codeProperties( currency, cldr )\n *\n * Return number pattern with the appropriate currency code in as literal.\n */\nvar currencyCodeProperties = function( currency, cldr ) {\n\tvar pattern = numberPattern( \"decimal\", cldr );\n\n\t// The number of decimal places and the rounding for each currency is not locale-specific. Those\n\t// values overridden by Supplemental Currency Data.\n\tpattern = currencySupplementalOverride( currency, pattern, cldr );\n\n\treturn {\n\t\tcurrency: currency,\n\t\tpattern: pattern,\n\t\tunitPatterns: currencyUnitPatterns( cldr )\n\t};\n};\n\n\n\n\n/**\n * nameFormat( formattedNumber, pluralForm, properties )\n *\n * Return the appropriate name form currency format.\n */\nvar currencyNameFormat = function( formattedNumber, pluralForm, properties ) {\n\tvar displayName, unitPattern,\n\t\tdisplayNames = properties.displayNames || {},\n\t\tunitPatterns = properties.unitPatterns;\n\n\tdisplayName = displayNames[ \"displayName-count-\" + pluralForm ] ||\n\t\tdisplayNames[ \"displayName-count-other\" ] ||\n\t\tdisplayNames.displayName ||\n\t\tproperties.currency;\n\tunitPattern = unitPatterns[ \"unitPattern-count-\" + pluralForm ] ||\n\t\tunitPatterns[ \"unitPattern-count-other\" ];\n\n\treturn formatMessage( unitPattern, [ formattedNumber, displayName ]);\n};\n\n\n\n\nvar currencyFormatterFn = function( numberFormatter, pluralGenerator, properties ) {\n\tvar fn;\n\n\t// Return formatter when style is \"code\" or \"name\".\n\tif ( pluralGenerator && properties ) {\n\t\tfn = function currencyFormatter( value ) {\n\t\t\tvalidateParameterPresence( value, \"value\" );\n\t\t\tvalidateParameterTypeNumber( value, \"value\" );\n\t\t\treturn currencyNameFormat(\n\t\t\t\tnumberFormatter( value ),\n\t\t\t\tpluralGenerator( value ),\n\t\t\t\tproperties\n\t\t\t);\n\t\t};\n\n\t// Return formatter when style is \"symbol\" or \"accounting\".\n\t} else {\n\t\tfn = function currencyFormatter( value ) {\n\t\t\treturn numberFormatter( value );\n\t\t};\n\t}\n\n\treturn fn;\n};\n\n\n\n\n/**\n * nameProperties( currency, cldr )\n *\n * Return number pattern with the appropriate currency code in as literal.\n */\nvar currencyNameProperties = function( currency, cldr ) {\n\tvar properties = currencyCodeProperties( currency, cldr );\n\n\tproperties.displayNames = objectFilter( cldr.main([\n\t\t\"numbers/currencies\",\n\t\tcurrency\n\t]), /^displayName/ );\n\n\treturn properties;\n};\n\n\n\n\n/**\n * Unicode regular expression for: everything except math symbols, currency signs, dingbats, and\n * box-drawing characters.\n *\n * Generated by:\n *\n * regenerate()\n *   .addRange( 0x0, 0x10FFFF )\n *   .remove( require( \"unicode-7.0.0/categories/S/symbols\" ) ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-7.0.0\n */\nvar regexpNotS = /[\\0-#%-\\*,-;\\?-\\]_a-\\{\\}\\x7F-\\xA1\\xA7\\xAA\\xAB\\xAD\\xB2\\xB3\\xB5-\\xB7\\xB9-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376-\\u0383\\u0386-\\u03F5\\u03F7-\\u0481\\u0483-\\u058C\\u0590-\\u0605\\u0609\\u060A\\u060C\\u060D\\u0610-\\u06DD\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF-\\u07F5\\u07F7-\\u09F1\\u09F4-\\u09F9\\u09FC-\\u0AF0\\u0AF2-\\u0B6F\\u0B71-\\u0BF2\\u0BFB-\\u0C7E\\u0C80-\\u0D78\\u0D7A-\\u0E3E\\u0E40-\\u0F00\\u0F04-\\u0F12\\u0F14\\u0F18\\u0F19\\u0F20-\\u0F33\\u0F35\\u0F37\\u0F39-\\u0FBD\\u0FC6\\u0FCD\\u0FD0-\\u0FD4\\u0FD9-\\u109D\\u10A0-\\u138F\\u139A-\\u17DA\\u17DC-\\u193F\\u1941-\\u19DD\\u1A00-\\u1B60\\u1B6B-\\u1B73\\u1B7D-\\u1FBC\\u1FBE\\u1FC2-\\u1FCC\\u1FD0-\\u1FDC\\u1FE0-\\u1FEC\\u1FF0-\\u1FFC\\u1FFF-\\u2043\\u2045-\\u2051\\u2053-\\u2079\\u207D-\\u2089\\u208D-\\u209F\\u20BE-\\u20FF\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u218F\\u2308-\\u230B\\u2329\\u232A\\u23FB-\\u23FF\\u2427-\\u243F\\u244B-\\u249B\\u24EA-\\u24FF\\u2768-\\u2793\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2B74\\u2B75\\u2B96\\u2B97\\u2BBA-\\u2BBC\\u2BC9\\u2BD2-\\u2CE4\\u2CEB-\\u2E7F\\u2E9A\\u2EF4-\\u2EFF\\u2FD6-\\u2FEF\\u2FFC-\\u3003\\u3005-\\u3011\\u3014-\\u301F\\u3021-\\u3035\\u3038-\\u303D\\u3040-\\u309A\\u309D-\\u318F\\u3192-\\u3195\\u31A0-\\u31BF\\u31E4-\\u31FF\\u321F-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u32FF\\u3400-\\u4DBF\\u4E00-\\uA48F\\uA4C7-\\uA6FF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA827\\uA82C-\\uA835\\uA83A-\\uAA76\\uAA7A-\\uAB5A\\uAB5C-\\uD7FF\\uDC00-\\uFB28\\uFB2A-\\uFBB1\\uFBC2-\\uFDFB\\uFDFE-\\uFE61\\uFE63\\uFE67\\uFE68\\uFE6A-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF1B\\uFF1F-\\uFF3D\\uFF3F\\uFF41-\\uFF5B\\uFF5D\\uFF5F-\\uFFDF\\uFFE7\\uFFEF-\\uFFFB\\uFFFE\\uFFFF]|\\uD800[\\uDC00-\\uDD36\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDD8D-\\uDD8F\\uDD9C-\\uDD9F\\uDDA1-\\uDDCF\\uDDFD-\\uDFFF]|[\\uD801\\uD803-\\uD819\\uD81B-\\uD82E\\uD830-\\uD833\\uD836-\\uD83A\\uD83F-\\uDBFF][\\uDC00-\\uDFFF]|\\uD802[\\uDC00-\\uDC76\\uDC79-\\uDEC7\\uDEC9-\\uDFFF]|\\uD81A[\\uDC00-\\uDF3B\\uDF40-\\uDF44\\uDF46-\\uDFFF]|\\uD82F[\\uDC00-\\uDC9B\\uDC9D-\\uDFFF]|\\uD834[\\uDCF6-\\uDCFF\\uDD27\\uDD28\\uDD65-\\uDD69\\uDD6D-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDDDE-\\uDDFF\\uDE42-\\uDE44\\uDE46-\\uDEFF\\uDF57-\\uDFFF]|\\uD835[\\uDC00-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFFF]|\\uD83B[\\uDC00-\\uDEEF\\uDEF2-\\uDFFF]|\\uD83C[\\uDC2C-\\uDC2F\\uDC94-\\uDC9F\\uDCAF\\uDCB0\\uDCC0\\uDCD0\\uDCF6-\\uDD0F\\uDD2F\\uDD6C-\\uDD6F\\uDD9B-\\uDDE5\\uDE03-\\uDE0F\\uDE3B-\\uDE3F\\uDE49-\\uDE4F\\uDE52-\\uDEFF\\uDF2D-\\uDF2F\\uDF7E\\uDF7F\\uDFCF-\\uDFD3\\uDFF8-\\uDFFF]|\\uD83D[\\uDCFF\\uDD4B-\\uDD4F\\uDD7A\\uDDA4\\uDE43\\uDE44\\uDED0-\\uDEDF\\uDEED-\\uDEEF\\uDEF4-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDFFF]|[\\uD800-\\uDBFF]/;\n\n\n\n\n/**\n * symbolProperties( currency, cldr )\n *\n * Return pattern replacing `¤` with the appropriate currency symbol literal.\n */\nvar currencySymbolProperties = function( currency, cldr, options ) {\n\tvar currencySpacing, pattern,\n\t\tregexp = {\n\t\t\t\"[:digit:]\": /\\d/,\n\t\t\t\"[:^S:]\": regexpNotS\n\t\t},\n\t\tsymbol = cldr.main([\n\t\t\t\"numbers/currencies\",\n\t\t\tcurrency,\n\t\t\t\"symbol\"\n\t\t]);\n\n\tcurrencySpacing = [ \"beforeCurrency\", \"afterCurrency\" ].map(function( position ) {\n\t\treturn cldr.main([\n\t\t\t\"numbers\",\n\t\t\t\"currencyFormats-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\t\t\"currencySpacing\",\n\t\t\tposition\n\t\t]);\n\t});\n\n\tpattern = cldr.main([\n\t\t\"numbers\",\n\t\t\"currencyFormats-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\toptions.style === \"accounting\" ? \"accounting\" : \"standard\"\n\t]);\n\n\tpattern =\n\n\t\t// The number of decimal places and the rounding for each currency is not locale-specific.\n\t\t// Those values are overridden by Supplemental Currency Data.\n\t\tcurrencySupplementalOverride( currency, pattern, cldr )\n\n\t\t// Replace \"¤\" (\\u00A4) with the appropriate symbol literal.\n\t\t.split( \";\" ).map(function( pattern ) {\n\n\t\t\treturn pattern.split( \"\\u00A4\" ).map(function( part, i ) {\n\t\t\t\tvar currencyMatch = regexp[ currencySpacing[ i ].currencyMatch ],\n\t\t\t\t\tsurroundingMatch = regexp[ currencySpacing[ i ].surroundingMatch ],\n\t\t\t\t\tinsertBetween = \"\";\n\n\t\t\t\t// For currencyMatch and surroundingMatch definitions, read [1].\n\t\t\t\t// When i === 0, beforeCurrency is being handled. Otherwise, afterCurrency.\n\t\t\t\t// 1: http://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies\n\t\t\t\tcurrencyMatch = currencyMatch.test( symbol.charAt( i ? symbol.length - 1 : 0 ) );\n\t\t\t\tsurroundingMatch = surroundingMatch.test(\n\t\t\t\t\tpart.charAt( i ? 0 : part.length - 1 ).replace( /[#@,.]/g, \"0\" )\n\t\t\t\t);\n\n\t\t\t\tif ( currencyMatch && part && surroundingMatch ) {\n\t\t\t\t\tinsertBetween = currencySpacing[ i ].insertBetween;\n\t\t\t\t}\n\n\t\t\t\treturn ( i ? insertBetween : \"\" ) + part + ( i ? \"\" : insertBetween );\n\t\t\t}).join( \"'\" + symbol + \"'\" );\n\t\t}).join( \";\" );\n\n\treturn {\n\t\tpattern: pattern\n\t};\n};\n\n\n\n\n/**\n * objectOmit( object, keys )\n *\n * Return a copy of the object, filtered to omit the blacklisted key or array of keys.\n */\nvar objectOmit = function( object, keys ) {\n\tvar key,\n\t\tcopy = {};\n\n\tkeys = alwaysArray( keys );\n\n\tfor ( key in object ) {\n\t\tif ( keys.indexOf( key ) === -1 ) {\n\t\t\tcopy[ key ] = object[ key ];\n\t\t}\n\t}\n\n\treturn copy;\n};\n\n\n\n\nfunction validateRequiredCldr( path, value ) {\n\tvalidateCldr( path, value, {\n\t\tskip: [ /supplemental\\/currencyData\\/fractions\\/[A-Za-z]{3}$/ ]\n\t});\n}\n\n/**\n * .currencyFormatter( currency [, options] )\n *\n * @currency [String] 3-letter currency code as defined by ISO 4217.\n *\n * @options [Object]:\n * - style: [String] \"symbol\" (default), \"accounting\", \"code\" or \"name\".\n * - see also number/format options.\n *\n * Return a function that formats a currency according to the given options and default/instance\n * locale.\n */\nGlobalize.currencyFormatter =\nGlobalize.prototype.currencyFormatter = function( currency, options ) {\n\tvar args, cldr, numberFormatter, pluralGenerator, properties, returnFn, style;\n\n\tvalidateParameterPresence( currency, \"currency\" );\n\tvalidateParameterTypeCurrency( currency, \"currency\" );\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\tcldr = this.cldr;\n\toptions = options || {};\n\n\targs = [ currency, options ];\n\tstyle = options.style || \"symbol\";\n\n\tvalidateDefaultLocale( cldr );\n\n\t// Get properties given style (\"symbol\" default, \"code\" or \"name\").\n\tcldr.on( \"get\", validateRequiredCldr );\n\tproperties = ({\n\t\taccounting: currencySymbolProperties,\n\t\tcode: currencyCodeProperties,\n\t\tname: currencyNameProperties,\n\t\tsymbol: currencySymbolProperties\n\t}[ style ] )( currency, cldr, options );\n\tcldr.off( \"get\", validateRequiredCldr );\n\n\t// options = options minus style, plus raw pattern.\n\toptions = objectOmit( options, \"style\" );\n\toptions.raw = properties.pattern;\n\n\t// Return formatter when style is \"symbol\" or \"accounting\".\n\tif ( style === \"symbol\" || style === \"accounting\" ) {\n\t\tnumberFormatter = this.numberFormatter( options );\n\n\t\treturnFn = currencyFormatterFn( numberFormatter );\n\n\t\truntimeBind( args, cldr, returnFn, [ numberFormatter ] );\n\n\t// Return formatter when style is \"code\" or \"name\".\n\t} else {\n\t\tnumberFormatter = this.numberFormatter( options );\n\t\tpluralGenerator = this.pluralGenerator();\n\n\t\treturnFn = currencyFormatterFn( numberFormatter, pluralGenerator, properties );\n\n\t\truntimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );\n\t}\n\n\treturn returnFn;\n};\n\n/**\n * .currencyParser( currency [, options] )\n *\n * @currency [String] 3-letter currency code as defined by ISO 4217.\n *\n * @options [Object] see currencyFormatter.\n *\n * Return the currency parser according to the given options and the default/instance locale.\n */\nGlobalize.currencyParser =\nGlobalize.prototype.currencyParser = function( /* currency, options */ ) {\n\n\t// TODO implement parser.\n\n};\n\n/**\n * .formatCurrency( value, currency [, options] )\n *\n * @value [Number] number to be formatted.\n *\n * @currency [String] 3-letter currency code as defined by ISO 4217.\n *\n * @options [Object] see currencyFormatter.\n *\n * Format a currency according to the given options and the default/instance locale.\n */\nGlobalize.formatCurrency =\nGlobalize.prototype.formatCurrency = function( value, currency, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\n\treturn this.currencyFormatter( currency, options )( value );\n};\n\n/**\n * .parseCurrency( value, currency [, options] )\n *\n * @value [String]\n *\n * @currency [String] 3-letter currency code as defined by ISO 4217.\n *\n * @options [Object]: See currencyFormatter.\n *\n * Return the parsed currency or NaN when value is invalid.\n */\nGlobalize.parseCurrency =\nGlobalize.prototype.parseCurrency = function( /* value, currency, options */ ) {\n};\n\nreturn Globalize;\n\n\n\n\n}));\n","/home/travis/build/npmtest/node-npmtest-globalize/node_modules/globalize/dist/globalize/date.js":"/**\n * Globalize v1.2.3\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2017-03-17T01:41Z\n */\n/*!\n * Globalize v1.2.3 2017-03-17T01:41Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"./number\",\n\t\t\t\"cldr/event\",\n\t\t\t\"cldr/supplemental\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Extend global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar createError = Globalize._createError,\n\tcreateErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,\n\tformatMessage = Globalize._formatMessage,\n\tnumberSymbol = Globalize._numberSymbol,\n\tregexpEscape = Globalize._regexpEscape,\n\tremoveLiteralQuotes = Globalize._removeLiteralQuotes,\n\truntimeBind = Globalize._runtimeBind,\n\tstringPad = Globalize._stringPad,\n\tvalidateCldr = Globalize._validateCldr,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,\n\tvalidateParameterTypeString = Globalize._validateParameterTypeString;\n\n\nvar validateParameterTypeDate = function( value, name ) {\n\tvalidateParameterType( value, name, value === undefined || value instanceof Date, \"Date\" );\n};\n\n\n\n\nvar createErrorInvalidParameterValue = function( name, value ) {\n\treturn createError( \"E_INVALID_PAR_VALUE\", \"Invalid `{name}` value ({value}).\", {\n\t\tname: name,\n\t\tvalue: value\n\t});\n};\n\n\n\n\n/**\n * expandPattern( options, cldr )\n *\n * @options [Object] if String, it's considered a skeleton. Object accepts:\n * - skeleton: [String] lookup availableFormat;\n * - date: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n * - time: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n * - datetime: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n * - raw: [String] For more info see datetime/format.js.\n *\n * @cldr [Cldr instance].\n *\n * Return the corresponding pattern.\n * Eg for \"en\":\n * - \"GyMMMd\" returns \"MMM d, y G\";\n * - { skeleton: \"GyMMMd\" } returns \"MMM d, y G\";\n * - { date: \"full\" } returns \"EEEE, MMMM d, y\";\n * - { time: \"full\" } returns \"h:mm:ss a zzzz\";\n * - { datetime: \"full\" } returns \"EEEE, MMMM d, y 'at' h:mm:ss a zzzz\";\n * - { raw: \"dd/mm\" } returns \"dd/mm\";\n */\n\nvar dateExpandPattern = function( options, cldr ) {\n\tvar dateSkeleton, result, skeleton, timeSkeleton, type;\n\n\tfunction combineDateTime( type, datePattern, timePattern ) {\n\t\treturn formatMessage(\n\t\t\tcldr.main([\n\t\t\t\t\"dates/calendars/gregorian/dateTimeFormats\",\n\t\t\t\ttype\n\t\t\t]),\n\t\t\t[ timePattern, datePattern ]\n\t\t);\n\t}\n\n\tswitch ( true ) {\n\t\tcase \"skeleton\" in options:\n\t\t\tskeleton = options.skeleton;\n\t\t\tresult = cldr.main([\n\t\t\t\t\"dates/calendars/gregorian/dateTimeFormats/availableFormats\",\n\t\t\t\tskeleton\n\t\t\t]);\n\t\t\tif ( !result ) {\n\t\t\t\ttimeSkeleton = skeleton.split( /[^hHKkmsSAzZOvVXx]/ ).slice( -1 )[ 0 ];\n\t\t\t\tdateSkeleton = skeleton.split( /[^GyYuUrQqMLlwWdDFgEec]/ )[ 0 ];\n\t\t\t\tif ( /(MMMM|LLLL).*[Ec]/.test( dateSkeleton ) ) {\n\t\t\t\t\ttype = \"full\";\n\t\t\t\t} else if ( /MMMM/g.test( dateSkeleton ) ) {\n\t\t\t\t\ttype = \"long\";\n\t\t\t\t} else if ( /MMM/g.test( dateSkeleton ) || /LLL/g.test( dateSkeleton ) ) {\n\t\t\t\t\ttype = \"medium\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = \"short\";\n\t\t\t\t}\n\t\t\t\tresult = combineDateTime( type,\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/dateTimeFormats/availableFormats\",\n\t\t\t\t\t\tdateSkeleton\n\t\t\t\t\t]),\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/dateTimeFormats/availableFormats\",\n\t\t\t\t\t\ttimeSkeleton\n\t\t\t\t\t])\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase \"date\" in options:\n\t\tcase \"time\" in options:\n\t\t\tresult = cldr.main([\n\t\t\t\t\"dates/calendars/gregorian\",\n\t\t\t\t\"date\" in options ? \"dateFormats\" : \"timeFormats\",\n\t\t\t\t( options.date || options.time )\n\t\t\t]);\n\t\t\tbreak;\n\n\t\tcase \"datetime\" in options:\n\t\t\tresult = combineDateTime( options.datetime,\n\t\t\t\tcldr.main([ \"dates/calendars/gregorian/dateFormats\", options.datetime ]),\n\t\t\t\tcldr.main([ \"dates/calendars/gregorian/timeFormats\", options.datetime ])\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase \"raw\" in options:\n\t\t\tresult = options.raw;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow createErrorInvalidParameterValue({\n\t\t\t\tname: \"options\",\n\t\t\t\tvalue: options\n\t\t\t});\n\t}\n\n\treturn result;\n};\n\n\n\n\n/**\n * dayOfWeek( date, firstDay )\n *\n * @date\n *\n * @firstDay the result of `dateFirstDayOfWeek( cldr )`\n *\n * Return the day of the week normalized by the territory's firstDay [0-6].\n * Eg for \"mon\":\n * - return 0 if territory is GB, or BR, or DE, or FR (week starts on \"mon\");\n * - return 1 if territory is US (week starts on \"sun\");\n * - return 2 if territory is EG (week starts on \"sat\");\n */\nvar dateDayOfWeek = function( date, firstDay ) {\n\treturn ( date.getDay() - firstDay + 7 ) % 7;\n};\n\n\n\n\n/**\n * distanceInDays( from, to )\n *\n * Return the distance in days between from and to Dates.\n */\nvar dateDistanceInDays = function( from, to ) {\n\tvar inDays = 864e5;\n\treturn ( to.getTime() - from.getTime() ) / inDays;\n};\n\n\n\n\n/**\n * startOf changes the input to the beginning of the given unit.\n *\n * For example, starting at the start of a day, resets hours, minutes\n * seconds and milliseconds to 0. Starting at the month does the same, but\n * also sets the date to 1.\n *\n * Returns the modified date\n */\nvar dateStartOf = function( date, unit ) {\n\tdate = new Date( date.getTime() );\n\tswitch ( unit ) {\n\t\tcase \"year\":\n\t\t\tdate.setMonth( 0 );\n\t\t/* falls through */\n\t\tcase \"month\":\n\t\t\tdate.setDate( 1 );\n\t\t/* falls through */\n\t\tcase \"day\":\n\t\t\tdate.setHours( 0 );\n\t\t/* falls through */\n\t\tcase \"hour\":\n\t\t\tdate.setMinutes( 0 );\n\t\t/* falls through */\n\t\tcase \"minute\":\n\t\t\tdate.setSeconds( 0 );\n\t\t/* falls through */\n\t\tcase \"second\":\n\t\t\tdate.setMilliseconds( 0 );\n\t}\n\treturn date;\n};\n\n\n\n\n/**\n * dayOfYear\n *\n * Return the distance in days of the date to the begin of the year [0-d].\n */\nvar dateDayOfYear = function( date ) {\n\treturn Math.floor( dateDistanceInDays( dateStartOf( date, \"year\" ), date ) );\n};\n\n\n\n\n/**\n * millisecondsInDay\n */\nvar dateMillisecondsInDay = function( date ) {\n\n\t// TODO Handle daylight savings discontinuities\n\treturn date - dateStartOf( date, \"day\" );\n};\n\n\n\n\nvar datePatternRe = ( /([a-z])\\1*|'([^']|'')+'|''|./ig );\n\n\n\n\n/**\n * hourFormat( date, format, timeSeparator, formatNumber )\n *\n * Return date's timezone offset according to the format passed.\n * Eg for format when timezone offset is 180:\n * - \"+H;-H\": -3\n * - \"+HHmm;-HHmm\": -0300\n * - \"+HH:mm;-HH:mm\": -03:00\n */\nvar dateTimezoneHourFormat = function( date, format, timeSeparator, formatNumber ) {\n\tvar absOffset,\n\t\toffset = date.getTimezoneOffset();\n\n\tabsOffset = Math.abs( offset );\n\tformatNumber = formatNumber || {\n\t\t1: function( value ) {\n\t\t\treturn stringPad( value, 1 );\n\t\t},\n\t\t2: function( value ) {\n\t\t\treturn stringPad( value, 2 );\n\t\t}\n\t};\n\n\treturn format\n\n\t\t// Pick the correct sign side (+ or -).\n\t\t.split( \";\" )[ offset > 0 ? 1 : 0 ]\n\n\t\t// Localize time separator\n\t\t.replace( \":\", timeSeparator )\n\n\t\t// Update hours offset.\n\t\t.replace( /HH?/, function( match ) {\n\t\t\treturn formatNumber[ match.length ]( Math.floor( absOffset / 60 ) );\n\t\t})\n\n\t\t// Update minutes offset and return.\n\t\t.replace( /mm/, function() {\n\t\t\treturn formatNumber[ 2 ]( absOffset % 60 );\n\t\t});\n};\n\n\n\n\nvar dateWeekDays = [ \"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\" ];\n\n\n\n\n/**\n * format( date, properties )\n *\n * @date [Date instance].\n *\n * @properties\n *\n * TODO Support other calendar types.\n *\n * Disclosure: this function borrows excerpts of dojo/date/locale.\n */\nvar dateFormat = function( date, numberFormatters, properties ) {\n\tvar timeSeparator = properties.timeSeparator;\n\n\treturn properties.pattern.replace( datePatternRe, function( current ) {\n\t\tvar ret,\n\t\t\tchr = current.charAt( 0 ),\n\t\t\tlength = current.length;\n\n\t\tif ( chr === \"j\" ) {\n\n\t\t\t// Locale preferred hHKk.\n\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n\t\t\tchr = properties.preferredTime;\n\t\t}\n\n\t\tif ( chr === \"Z\" ) {\n\n\t\t\t// Z..ZZZ: same as \"xxxx\".\n\t\t\tif ( length < 4 ) {\n\t\t\t\tchr = \"x\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZ: same as \"OOOO\".\n\t\t\t} else if ( length < 5 ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZZ: same as \"XXXXX\"\n\t\t\t} else {\n\t\t\t\tchr = \"X\";\n\t\t\t\tlength = 5;\n\t\t\t}\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tret = properties.eras[ date.getFullYear() < 0 ? 0 : 1 ];\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\n\t\t\t\t// Plain year.\n\t\t\t\t// The length specifies the padding, but for two letters it also specifies the\n\t\t\t\t// maximum length.\n\t\t\t\tret = date.getFullYear();\n\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\tret = String( ret );\n\t\t\t\t\tret = +ret.substr( ret.length - 2 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Y\":\n\n\t\t\t\t// Year in \"Week of Year\"\n\t\t\t\t// The length specifies the padding, but for two letters it also specifies the\n\t\t\t\t// maximum length.\n\t\t\t\t// yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays\n\t\t\t\tret = new Date( date.getTime() );\n\t\t\t\tret.setDate(\n\t\t\t\t\tret.getDate() + 7 -\n\t\t\t\t\tdateDayOfWeek( date, properties.firstDay ) -\n\t\t\t\t\tproperties.firstDay -\n\t\t\t\t\tproperties.minDays\n\t\t\t\t);\n\t\t\t\tret = ret.getFullYear();\n\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\tret = String( ret );\n\t\t\t\t\tret = +ret.substr( ret.length - 2 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tret = Math.ceil( ( date.getMonth() + 1 ) / 3 );\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tret = properties.quarters[ chr ][ length ][ ret ];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tret = date.getMonth() + 1;\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tret = properties.months[ chr ][ length ][ ret ];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Week\n\t\t\tcase \"w\":\n\n\t\t\t\t// Week of Year.\n\t\t\t\t// woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.\n\t\t\t\t// TODO should pad on ww? Not documented, but I guess so.\n\t\t\t\tret = dateDayOfWeek( dateStartOf( date, \"year\" ), properties.firstDay );\n\t\t\t\tret = Math.ceil( ( dateDayOfYear( date ) + ret ) / 7 ) -\n\t\t\t\t\t( 7 - ret >= properties.minDays ? 0 : 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase \"W\":\n\n\t\t\t\t// Week of Month.\n\t\t\t\t// wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.\n\t\t\t\tret = dateDayOfWeek( dateStartOf( date, \"month\" ), properties.firstDay );\n\t\t\t\tret = Math.ceil( ( date.getDate() + ret ) / 7 ) -\n\t\t\t\t\t( 7 - ret >= properties.minDays ? 0 : 1 );\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"d\":\n\t\t\t\tret = date.getDate();\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tret = dateDayOfYear( date ) + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase \"F\":\n\n\t\t\t\t// Day of Week in month. eg. 2nd Wed in July.\n\t\t\t\tret = Math.floor( date.getDate() / 7 ) + 1;\n\t\t\t\tbreak;\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\t\t\t\tif ( length <= 2 ) {\n\n\t\t\t\t\t// Range is [1-7] (deduced by example provided on documentation)\n\t\t\t\t\t// TODO Should pad with zeros (not specified in the docs)?\n\t\t\t\t\tret = dateDayOfWeek( date, properties.firstDay ) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tret = dateWeekDays[ date.getDay() ];\n\t\t\t\tret = properties.days[ chr ][ length ][ ret ];\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tret = properties.dayPeriods[ date.getHours() < 12 ? \"am\" : \"pm\" ];\n\t\t\t\tbreak;\n\n\t\t\t// Hour\n\t\t\tcase \"h\": // 1-12\n\t\t\t\tret = ( date.getHours() % 12 ) || 12;\n\t\t\t\tbreak;\n\n\t\t\tcase \"H\": // 0-23\n\t\t\t\tret = date.getHours();\n\t\t\t\tbreak;\n\n\t\t\tcase \"K\": // 0-11\n\t\t\t\tret = date.getHours() % 12;\n\t\t\t\tbreak;\n\n\t\t\tcase \"k\": // 1-24\n\t\t\t\tret = date.getHours() || 24;\n\t\t\t\tbreak;\n\n\t\t\t// Minute\n\t\t\tcase \"m\":\n\t\t\t\tret = date.getMinutes();\n\t\t\t\tbreak;\n\n\t\t\t// Second\n\t\t\tcase \"s\":\n\t\t\t\tret = date.getSeconds();\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\tret = Math.round( date.getMilliseconds() * Math.pow( 10, length - 3 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase \"A\":\n\t\t\t\tret = Math.round( dateMillisecondsInDay( date ) * Math.pow( 10, length - 3 ) );\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"z\":\n\t\t\tcase \"O\":\n\n\t\t\t\t// O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n\t\t\t\t// OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n\t\t\t\tif ( date.getTimezoneOffset() === 0 ) {\n\t\t\t\t\tret = properties.gmtZeroFormat;\n\t\t\t\t} else {\n\t\t\t\t\tret = dateTimezoneHourFormat(\n\t\t\t\t\t\tdate,\n\t\t\t\t\t\tlength < 4 ? \"+H;-H\" : properties.tzLongHourFormat,\n\t\t\t\t\t\ttimeSeparator,\n\t\t\t\t\t\tnumberFormatters\n\t\t\t\t\t);\n\t\t\t\t\tret = properties.gmtFormat.replace( /\\{0\\}/, ret );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"X\":\n\n\t\t\t\t// Same as x*, except it uses \"Z\" for zero offset.\n\t\t\t\tif ( date.getTimezoneOffset() === 0 ) {\n\t\t\t\t\tret = \"Z\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"x\":\n\n\t\t\t\t// x: hourFormat(\"+HH;-HH\")\n\t\t\t\t// xx or xxxx: hourFormat(\"+HHmm;-HHmm\")\n\t\t\t\t// xxx or xxxxx: hourFormat(\"+HH:mm;-HH:mm\")\n\t\t\t\tret = length === 1 ? \"+HH;-HH\" : ( length % 2 ? \"+HH:mm;-HH:mm\" : \"+HHmm;-HHmm\" );\n\t\t\t\tret = dateTimezoneHourFormat( date, ret, \":\" );\n\t\t\t\tbreak;\n\n\t\t\t// timeSeparator\n\t\t\tcase \":\":\n\t\t\t\tret = timeSeparator;\n\t\t\t\tbreak;\n\n\t\t\t// ' literals.\n\t\t\tcase \"'\":\n\t\t\t\tret = removeLiteralQuotes( current );\n\t\t\t\tbreak;\n\n\t\t\t// Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and\n\t\t\t// arabic characters.\n\t\t\tdefault:\n\t\t\t\tret = current;\n\t\t}\n\t\tif ( typeof ret === \"number\" ) {\n\t\t\tret = numberFormatters[ length ]( ret );\n\t\t}\n\t\treturn ret;\n\t});\n};\n\n\n\n\nvar dateFormatterFn = function( numberFormatters, properties ) {\n\treturn function dateFormatter( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeDate( value, \"value\" );\n\n\t\treturn dateFormat( value, numberFormatters, properties );\n\t};\n\n};\n\n\n\n\n/**\n * firstDayOfWeek\n */\nvar dateFirstDayOfWeek = function( cldr ) {\n\treturn dateWeekDays.indexOf( cldr.supplemental.weekData.firstDay() );\n};\n\n\n\n\n/**\n * properties( pattern, cldr )\n *\n * @pattern [String] raw pattern.\n * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n *\n * @cldr [Cldr instance].\n *\n * Return the properties given the pattern and cldr.\n *\n * TODO Support other calendar types.\n */\nvar dateFormatProperties = function( pattern, cldr ) {\n\tvar properties = {\n\t\t\tnumberFormatters: {},\n\t\t\tpattern: pattern,\n\t\t\ttimeSeparator: numberSymbol( \"timeSeparator\", cldr )\n\t\t},\n\t\twidths = [ \"abbreviated\", \"wide\", \"narrow\" ];\n\n\tfunction setNumberFormatterPattern( pad ) {\n\t\tproperties.numberFormatters[ pad ] = stringPad( \"\", pad );\n\t}\n\n\tpattern.replace( datePatternRe, function( current ) {\n\t\tvar formatNumber,\n\t\t\tchr = current.charAt( 0 ),\n\t\t\tlength = current.length;\n\n\t\tif ( chr === \"j\" ) {\n\n\t\t\t// Locale preferred hHKk.\n\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n\t\t\tproperties.preferredTime = chr = cldr.supplemental.timeData.preferred();\n\t\t}\n\n\t\t// ZZZZ: same as \"OOOO\".\n\t\tif ( chr === \"Z\" && length === 4 ) {\n\t\t\tchr = \"O\";\n\t\t\tlength = 4;\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tproperties.eras = cldr.main([\n\t\t\t\t\t\"dates/calendars/gregorian/eras\",\n\t\t\t\t\tlength <= 3 ? \"eraAbbr\" : ( length === 4 ? \"eraNames\" : \"eraNarrow\" )\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\n\t\t\t\t// Plain year.\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\tcase \"Y\":\n\n\t\t\t\t// Year in \"Week of Year\"\n\t\t\t\tproperties.firstDay = dateFirstDayOfWeek( cldr );\n\t\t\t\tproperties.minDays = cldr.supplemental.weekData.minDays();\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\tcase \"u\": // Extended year. Need to be implemented.\n\t\t\tcase \"U\": // Cyclic year name. Need to be implemented.\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"year pattern `\" + chr + \"`\"\n\t\t\t\t});\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tif ( !properties.quarters ) {\n\t\t\t\t\t\tproperties.quarters = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( !properties.quarters[ chr ] ) {\n\t\t\t\t\t\tproperties.quarters[ chr ] = {};\n\t\t\t\t\t}\n\t\t\t\t\tproperties.quarters[ chr ][ length ] = cldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/quarters\",\n\t\t\t\t\t\tchr === \"Q\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tformatNumber = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tif ( !properties.months ) {\n\t\t\t\t\t\tproperties.months = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( !properties.months[ chr ] ) {\n\t\t\t\t\t\tproperties.months[ chr ] = {};\n\t\t\t\t\t}\n\t\t\t\t\tproperties.months[ chr ][ length ] = cldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/months\",\n\t\t\t\t\t\tchr === \"M\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tformatNumber = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Week - Week of Year (w) or Week of Month (W).\n\t\t\tcase \"w\":\n\t\t\tcase \"W\":\n\t\t\t\tproperties.firstDay = dateFirstDayOfWeek( cldr );\n\t\t\t\tproperties.minDays = cldr.supplemental.weekData.minDays();\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"d\":\n\t\t\tcase \"D\":\n\t\t\tcase \"F\":\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\tcase \"g\":\n\n\t\t\t\t// Modified Julian day. Need to be implemented.\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"Julian day pattern `g`\"\n\t\t\t\t});\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\tproperties.firstDay = dateFirstDayOfWeek( cldr );\n\t\t\t\t\tformatNumber = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tif ( !properties.days ) {\n\t\t\t\t\tproperties.days = {};\n\t\t\t\t}\n\t\t\t\tif ( !properties.days[ chr ] ) {\n\t\t\t\t\tproperties.days[ chr ] = {};\n\t\t\t\t}\n\t\t\t\tif ( length === 6 ) {\n\n\t\t\t\t\t// If short day names are not explicitly specified, abbreviated day names are\n\t\t\t\t\t// used instead.\n\t\t\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n\t\t\t\t\t// http://unicode.org/cldr/trac/ticket/6790\n\t\t\t\t\tproperties.days[ chr ][ length ] = cldr.main([\n\t\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t\tchr === \"c\" ? \"stand-alone\" : \"format\",\n\t\t\t\t\t\t\t\"short\"\n\t\t\t\t\t\t]) || cldr.main([\n\t\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t\tchr === \"c\" ? \"stand-alone\" : \"format\",\n\t\t\t\t\t\t\t\"abbreviated\"\n\t\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tproperties.days[ chr ][ length ] = cldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\tchr === \"c\" ? \"stand-alone\" : \"format\",\n\t\t\t\t\t\twidths[ length < 3 ? 0 : length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tproperties.dayPeriods = {\n\t\t\t\t\tam: cldr.main(\n\t\t\t\t\t\t\"dates/calendars/gregorian/dayPeriods/format/wide/am\"\n\t\t\t\t\t),\n\t\t\t\t\tpm: cldr.main(\n\t\t\t\t\t\t\"dates/calendars/gregorian/dayPeriods/format/wide/pm\"\n\t\t\t\t\t)\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\t// Hour\n\t\t\tcase \"h\": // 1-12\n\t\t\tcase \"H\": // 0-23\n\t\t\tcase \"K\": // 0-11\n\t\t\tcase \"k\": // 1-24\n\n\t\t\t// Minute\n\t\t\tcase \"m\":\n\n\t\t\t// Second\n\t\t\tcase \"s\":\n\t\t\tcase \"S\":\n\t\t\tcase \"A\":\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"z\":\n\t\t\tcase \"O\":\n\n\t\t\t\t// O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n\t\t\t\t// OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n\t\t\t\tproperties.gmtFormat = cldr.main( \"dates/timeZoneNames/gmtFormat\" );\n\t\t\t\tproperties.gmtZeroFormat = cldr.main( \"dates/timeZoneNames/gmtZeroFormat\" );\n\t\t\t\tproperties.tzLongHourFormat = cldr.main( \"dates/timeZoneNames/hourFormat\" );\n\n\t\t\t/* falls through */\n\t\t\tcase \"Z\":\n\t\t\tcase \"X\":\n\t\t\tcase \"x\":\n\t\t\t\tsetNumberFormatterPattern( 1 );\n\t\t\t\tsetNumberFormatterPattern( 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase \"v\":\n\t\t\tcase \"V\":\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"timezone pattern `\" + chr + \"`\"\n\t\t\t\t});\n\t\t}\n\n\t\tif ( formatNumber ) {\n\t\t\tsetNumberFormatterPattern( length );\n\t\t}\n\t});\n\n\treturn properties;\n};\n\n\n\n\n/**\n * isLeapYear( year )\n *\n * @year [Number]\n *\n * Returns an indication whether the specified year is a leap year.\n */\nvar dateIsLeapYear = function( year ) {\n\treturn new Date( year, 1, 29 ).getMonth() === 1;\n};\n\n\n\n\n/**\n * lastDayOfMonth( date )\n *\n * @date [Date]\n *\n * Return the last day of the given date's month\n */\nvar dateLastDayOfMonth = function( date ) {\n\treturn new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();\n};\n\n\n\n\n/**\n * Differently from native date.setDate(), this function returns a date whose\n * day remains inside the month boundaries. For example:\n *\n * setDate( FebDate, 31 ): a \"Feb 28\" date.\n * setDate( SepDate, 31 ): a \"Sep 30\" date.\n */\nvar dateSetDate = function( date, day ) {\n\tvar lastDay = new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();\n\n\tdate.setDate( day < 1 ? 1 : day < lastDay ? day : lastDay );\n};\n\n\n\n\n/**\n * Differently from native date.setMonth(), this function adjusts date if\n * needed, so final month is always the one set.\n *\n * setMonth( Jan31Date, 1 ): a \"Feb 28\" date.\n * setDate( Jan31Date, 8 ): a \"Sep 30\" date.\n */\nvar dateSetMonth = function( date, month ) {\n\tvar originalDate = date.getDate();\n\n\tdate.setDate( 1 );\n\tdate.setMonth( month );\n\tdateSetDate( date, originalDate );\n};\n\n\n\n\nvar outOfRange = function( value, low, high ) {\n\treturn value < low || value > high;\n};\n\n\n\n\n/**\n * parse( value, tokens, properties )\n *\n * @value [String] string date.\n *\n * @tokens [Object] tokens returned by date/tokenizer.\n *\n * @properties [Object] output returned by date/tokenizer-properties.\n *\n * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n */\nvar dateParse = function( value, tokens, properties ) {\n\tvar amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid,\n\t\tYEAR = 0,\n\t\tMONTH = 1,\n\t\tDAY = 2,\n\t\tHOUR = 3,\n\t\tMINUTE = 4,\n\t\tSECOND = 5,\n\t\tMILLISECONDS = 6,\n\t\tdate = new Date(),\n\t\ttruncateAt = [],\n\t\tunits = [ \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"milliseconds\" ];\n\n\tif ( !tokens.length ) {\n\t\treturn null;\n\t}\n\n\tvalid = tokens.every(function( token ) {\n\t\tvar century, chr, value, length;\n\n\t\tif ( token.type === \"literal\" ) {\n\n\t\t\t// continue\n\t\t\treturn true;\n\t\t}\n\n\t\tchr = token.type.charAt( 0 );\n\t\tlength = token.type.length;\n\n\t\tif ( chr === \"j\" ) {\n\n\t\t\t// Locale preferred hHKk.\n\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n\t\t\tchr = properties.preferredTimeData;\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\ttruncateAt.push( YEAR );\n\t\t\t\tera = +token.value;\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\tif ( outOfRange( value, 0, 99 ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// mimic dojo/date/locale: choose century to apply, according to a sliding\n\t\t\t\t\t// window of 80 years before and 20 years after present year.\n\t\t\t\t\tcentury = Math.floor( date.getFullYear() / 100 ) * 100;\n\t\t\t\t\tvalue += century;\n\t\t\t\t\tif ( value > date.getFullYear() + 20 ) {\n\t\t\t\t\t\tvalue -= 100;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdate.setFullYear( value );\n\t\t\t\ttruncateAt.push( YEAR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"Y\": // Year in \"Week of Year\"\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"year pattern `\" + chr + \"`\"\n\t\t\t\t});\n\n\t\t\t// Quarter (skip)\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\tvalue = token.value;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = +token.value;\n\t\t\t\t}\n\t\t\t\tif ( outOfRange( value, 1, 12 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Setting the month later so that we have the correct year and can determine\n\t\t\t\t// the correct last day of February in case of leap year.\n\t\t\t\tmonth = value;\n\t\t\t\ttruncateAt.push( MONTH );\n\t\t\t\tbreak;\n\n\t\t\t// Week (skip)\n\t\t\tcase \"w\": // Week of Year.\n\t\t\tcase \"W\": // Week of Month.\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"d\":\n\t\t\t\tday = token.value;\n\t\t\t\ttruncateAt.push( DAY );\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tdaysOfYear = token.value;\n\t\t\t\ttruncateAt.push( DAY );\n\t\t\t\tbreak;\n\n\t\t\tcase \"F\":\n\n\t\t\t\t// Day of Week in month. eg. 2nd Wed in July.\n\t\t\t\t// Skip\n\t\t\t\tbreak;\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\t\t\tcase \"E\":\n\n\t\t\t\t// Skip.\n\t\t\t\t// value = arrayIndexOf( dateWeekDays, token.value );\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tamPm = token.value;\n\t\t\t\tbreak;\n\n\t\t\t// Hour\n\t\t\tcase \"h\": // 1-12\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 1, 12 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = hour12 = true;\n\t\t\t\tdate.setHours( value === 12 ? 0 : value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"K\": // 0-11\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 11 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = hour12 = true;\n\t\t\t\tdate.setHours( value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"k\": // 1-24\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 1, 24 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = true;\n\t\t\t\tdate.setHours( value === 24 ? 0 : value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"H\": // 0-23\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 23 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = true;\n\t\t\t\tdate.setHours( value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\t// Minute\n\t\t\tcase \"m\":\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 59 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdate.setMinutes( value );\n\t\t\t\ttruncateAt.push( MINUTE );\n\t\t\t\tbreak;\n\n\t\t\t// Second\n\t\t\tcase \"s\":\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 59 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdate.setSeconds( value );\n\t\t\t\ttruncateAt.push( SECOND );\n\t\t\t\tbreak;\n\n\t\t\tcase \"A\":\n\t\t\t\tdate.setHours( 0 );\n\t\t\t\tdate.setMinutes( 0 );\n\t\t\t\tdate.setSeconds( 0 );\n\n\t\t\t/* falls through */\n\t\t\tcase \"S\":\n\t\t\t\tvalue = Math.round( token.value * Math.pow( 10, 3 - length ) );\n\t\t\t\tdate.setMilliseconds( value );\n\t\t\t\ttruncateAt.push( MILLISECONDS );\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"Z\":\n\t\t\tcase \"z\":\n\t\t\tcase \"O\":\n\t\t\tcase \"X\":\n\t\t\tcase \"x\":\n\t\t\t\ttimezoneOffset = token.value;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t});\n\n\tif ( !valid ) {\n\t\treturn null;\n\t}\n\n\t// 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null\n\t// if amPm && !hour12 || !amPm && hour12.\n\tif ( hour && !( !amPm ^ hour12 ) ) {\n\t\treturn null;\n\t}\n\n\tif ( era === 0 ) {\n\n\t\t// 1 BC = year 0\n\t\tdate.setFullYear( date.getFullYear() * -1 + 1 );\n\t}\n\n\tif ( month !== undefined ) {\n\t\tdateSetMonth( date, month - 1 );\n\t}\n\n\tif ( day !== undefined ) {\n\t\tif ( outOfRange( day, 1, dateLastDayOfMonth( date ) ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tdate.setDate( day );\n\t} else if ( daysOfYear !== undefined ) {\n\t\tif ( outOfRange( daysOfYear, 1, dateIsLeapYear( date.getFullYear() ) ? 366 : 365 ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tdate.setMonth( 0 );\n\t\tdate.setDate( daysOfYear );\n\t}\n\n\tif ( hour12 && amPm === \"pm\" ) {\n\t\tdate.setHours( date.getHours() + 12 );\n\t}\n\n\tif ( timezoneOffset !== undefined ) {\n\t\tdate.setMinutes( date.getMinutes() + timezoneOffset - date.getTimezoneOffset() );\n\t}\n\n\t// Truncate date at the most precise unit defined. Eg.\n\t// If value is \"12/31\", and pattern is \"MM/dd\":\n\t// => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );\n\ttruncateAt = Math.max.apply( null, truncateAt );\n\tdate = dateStartOf( date, units[ truncateAt ] );\n\n\treturn date;\n};\n\n\n\n\n/**\n * Generated by:\n *\n * regenerate().add( require( \"unicode-7.0.0/categories/N/symbols\" ) ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-7.0.0\n */\nvar regexpN = /[0-9\\xB2\\xB3\\xB9\\xBC-\\xBE\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u09F4-\\u09F9\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0B72-\\u0B77\\u0BE6-\\u0BF2\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0CE6-\\u0CEF\\u0D66-\\u0D75\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F33\\u1040-\\u1049\\u1090-\\u1099\\u1369-\\u137C\\u16EE-\\u16F0\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19DA\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\u2070\\u2074-\\u2079\\u2080-\\u2089\\u2150-\\u2182\\u2185-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2CFD\\u3007\\u3021-\\u3029\\u3038-\\u303A\\u3192-\\u3195\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\uA620-\\uA629\\uA6E6-\\uA6EF\\uA830-\\uA835\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]|\\uD800[\\uDD07-\\uDD33\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDEE1-\\uDEFB\\uDF20-\\uDF23\\uDF41\\uDF4A\\uDFD1-\\uDFD5]|\\uD801[\\uDCA0-\\uDCA9]|\\uD802[\\uDC58-\\uDC5F\\uDC79-\\uDC7F\\uDCA7-\\uDCAF\\uDD16-\\uDD1B\\uDE40-\\uDE47\\uDE7D\\uDE7E\\uDE9D-\\uDE9F\\uDEEB-\\uDEEF\\uDF58-\\uDF5F\\uDF78-\\uDF7F\\uDFA9-\\uDFAF]|\\uD803[\\uDE60-\\uDE7E]|\\uD804[\\uDC52-\\uDC6F\\uDCF0-\\uDCF9\\uDD36-\\uDD3F\\uDDD0-\\uDDD9\\uDDE1-\\uDDF4\\uDEF0-\\uDEF9]|\\uD805[\\uDCD0-\\uDCD9\\uDE50-\\uDE59\\uDEC0-\\uDEC9]|\\uD806[\\uDCE0-\\uDCF2]|\\uD809[\\uDC00-\\uDC6E]|\\uD81A[\\uDE60-\\uDE69\\uDF50-\\uDF59\\uDF5B-\\uDF61]|\\uD834[\\uDF60-\\uDF71]|\\uD835[\\uDFCE-\\uDFFF]|\\uD83A[\\uDCC7-\\uDCCF]|\\uD83C[\\uDD00-\\uDD0C]/;\n\n\n\n\n/**\n * tokenizer( value, pattern, properties )\n *\n * @value [String] string date.\n *\n * @properties [Object] output returned by date/tokenizer-properties.\n *\n * Returns an Array of tokens, eg. value \"5 o'clock PM\", pattern \"h 'o''clock' a\":\n * [{\n *   type: \"h\",\n *   lexeme: \"5\"\n * }, {\n *   type: \"literal\",\n *   lexeme: \" \"\n * }, {\n *   type: \"literal\",\n *   lexeme: \"o'clock\"\n * }, {\n *   type: \"literal\",\n *   lexeme: \" \"\n * }, {\n *   type: \"a\",\n *   lexeme: \"PM\",\n *   value: \"pm\"\n * }]\n *\n * OBS: lexeme's are always String and may return invalid ranges depending of the token type.\n * Eg. \"99\" for month number.\n *\n * Return an empty Array when not successfully parsed.\n */\nvar dateTokenizer = function( value, numberParser, properties ) {\n\tvar valid,\n\t\ttimeSeparator = properties.timeSeparator,\n\t\ttokens = [],\n\t\twidths = [ \"abbreviated\", \"wide\", \"narrow\" ];\n\n\tvalid = properties.pattern.match( datePatternRe ).every(function( current ) {\n\t\tvar chr, length, numeric, tokenRe,\n\t\t\ttoken = {};\n\n\t\tfunction hourFormatParse( tokenRe, numberParser ) {\n\t\t\tvar aux = value.match( tokenRe );\n\t\t\tnumberParser = numberParser || function( value ) {\n\t\t\t\treturn +value;\n\t\t\t};\n\n\t\t\tif ( !aux ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// hourFormat containing H only, e.g., `+H;-H`\n\t\t\tif ( aux.length < 8 ) {\n\t\t\t\ttoken.value =\n\t\t\t\t\t( aux[ 1 ] ? -numberParser( aux[ 1 ] ) : numberParser( aux[ 4 ] ) ) * 60;\n\n\t\t\t// hourFormat containing H and m, e.g., `+HHmm;-HHmm`\n\t\t\t} else {\n\t\t\t\ttoken.value =\n\t\t\t\t\t( aux[ 1 ] ? -numberParser( aux[ 1 ] ) : numberParser( aux[ 7 ] ) ) * 60 +\n\t\t\t\t\t( aux[ 1 ] ? -numberParser( aux[ 4 ] ) : numberParser( aux[ 10 ] ) );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Transform:\n\t\t// - \"+H;-H\" -> /\\+(\\d\\d?)|-(\\d\\d?)/\n\t\t// - \"+HH;-HH\" -> /\\+(\\d\\d)|-(\\d\\d)/\n\t\t// - \"+HHmm;-HHmm\" -> /\\+(\\d\\d)(\\d\\d)|-(\\d\\d)(\\d\\d)/\n\t\t// - \"+HH:mm;-HH:mm\" -> /\\+(\\d\\d):(\\d\\d)|-(\\d\\d):(\\d\\d)/\n\t\t//\n\t\t// If gmtFormat is GMT{0}, the regexp must fill {0} in each side, e.g.:\n\t\t// - \"+H;-H\" -> /GMT\\+(\\d\\d?)|GMT-(\\d\\d?)/\n\t\tfunction hourFormatRe( hourFormat, gmtFormat, timeSeparator ) {\n\t\t\tvar re;\n\n\t\t\tif ( !gmtFormat ) {\n\t\t\t\tgmtFormat = \"{0}\";\n\t\t\t}\n\n\t\t\tre = hourFormat\n\t\t\t\t.replace( \"+\", \"\\\\+\" )\n\n\t\t\t\t// Unicode equivalent to (\\\\d\\\\d)\n\t\t\t\t.replace( /HH|mm/g, \"((\" + regexpN.source + \")(\" + regexpN.source + \"))\" )\n\n\t\t\t\t// Unicode equivalent to (\\\\d\\\\d?)\n\t\t\t\t.replace( /H|m/g, \"((\" + regexpN.source + \")(\" + regexpN.source + \")?)\" );\n\n\t\t\tif ( timeSeparator ) {\n\t\t\t\tre = re.replace( /:/g, timeSeparator );\n\t\t\t}\n\n\t\t\tre = re.split( \";\" ).map(function( part ) {\n\t\t\t\treturn gmtFormat.replace( \"{0}\", part );\n\t\t\t}).join( \"|\" );\n\n\t\t\treturn new RegExp( re );\n\t\t}\n\n\t\tfunction oneDigitIfLengthOne() {\n\t\t\tif ( length === 1 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = regexpN;\n\t\t\t}\n\t\t}\n\n\t\tfunction oneOrTwoDigitsIfLengthOne() {\n\t\t\tif ( length === 1 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d\\d?/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = new RegExp( \"(\" + regexpN.source + \"){1,2}\" );\n\t\t\t}\n\t\t}\n\n\t\tfunction oneOrTwoDigitsIfLengthOneOrTwo() {\n\t\t\tif ( length === 1 || length === 2 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d\\d?/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = new RegExp( \"(\" + regexpN.source + \"){1,2}\" );\n\t\t\t}\n\t\t}\n\n\t\tfunction twoDigitsIfLengthTwo() {\n\t\t\tif ( length === 2 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d\\d/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = new RegExp( \"(\" + regexpN.source + \"){2}\" );\n\t\t\t}\n\t\t}\n\n\t\t// Brute-force test every locale entry in an attempt to match the given value.\n\t\t// Return the first found one (and set token accordingly), or null.\n\t\tfunction lookup( path ) {\n\t\t\tvar i, re,\n\t\t\t\tdata = properties[ path.join( \"/\" ) ];\n\n\t\t\tfor ( i in data ) {\n\t\t\t\tre = new RegExp( \"^\" + data[ i ] );\n\t\t\t\tif ( re.test( value ) ) {\n\t\t\t\t\ttoken.value = i;\n\t\t\t\t\treturn tokenRe = new RegExp( data[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\ttoken.type = current;\n\t\tchr = current.charAt( 0 ),\n\t\tlength = current.length;\n\n\t\tif ( chr === \"Z\" ) {\n\n\t\t\t// Z..ZZZ: same as \"xxxx\".\n\t\t\tif ( length < 4 ) {\n\t\t\t\tchr = \"x\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZ: same as \"OOOO\".\n\t\t\t} else if ( length < 5 ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZZ: same as \"XXXXX\"\n\t\t\t} else {\n\t\t\t\tchr = \"X\";\n\t\t\t\tlength = 5;\n\t\t\t}\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tlookup([\n\t\t\t\t\t\"gregorian/eras\",\n\t\t\t\t\tlength <= 3 ? \"eraAbbr\" : ( length === 4 ? \"eraNames\" : \"eraNarrow\" )\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\t\t\tcase \"Y\":\n\t\t\t\tnumeric = true;\n\n\t\t\t\t// number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...\n\t\t\t\tif ( length === 1 ) {\n\n\t\t\t\t\t// Unicode equivalent to /\\d+/.\n\t\t\t\t\ttokenRe = new RegExp( \"(\" + regexpN.source + \")+\" );\n\t\t\t\t} else if ( length === 2 ) {\n\n\t\t\t\t\t// Lenient parsing: there's no year pattern to indicate non-zero-padded 2-digits\n\t\t\t\t\t// year, so parser accepts both zero-padded and non-zero-padded for `yy`.\n\t\t\t\t\t//\n\t\t\t\t\t// Unicode equivalent to /\\d\\d?/\n\t\t\t\t\ttokenRe = new RegExp( \"(\" + regexpN.source + \"){1,2}\" );\n\t\t\t\t} else {\n\n\t\t\t\t\t// Unicode equivalent to /\\d{length,}/\n\t\t\t\t\ttokenRe = new RegExp( \"(\" + regexpN.source + \"){\" + length + \",}\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\n\t\t\t\t// number l=1:{1}, l=2:{2}.\n\t\t\t\t// lookup l=3...\n\t\t\t\toneDigitIfLengthOne() || twoDigitsIfLengthTwo() ||\n\t\t\t\t\tlookup([\n\t\t\t\t\t\t\"gregorian/quarters\",\n\t\t\t\t\t\tchr === \"Q\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\n\t\t\t\t// number l=1:{1,2}, l=2:{2}.\n\t\t\t\t// lookup l=3...\n\t\t\t\t//\n\t\t\t\t// Lenient parsing: skeleton \"yMd\" (i.e., one M) may include MM for the pattern,\n\t\t\t\t// therefore parser accepts both zero-padded and non-zero-padded for M and MM.\n\t\t\t\t// Similar for L.\n\t\t\t\toneOrTwoDigitsIfLengthOneOrTwo() || lookup([\n\t\t\t\t\t\"gregorian/months\",\n\t\t\t\t\tchr === \"M\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"D\":\n\n\t\t\t\t// number {l,3}.\n\t\t\t\tif ( length <= 3 ) {\n\n\t\t\t\t\t// Equivalent to /\\d{length,3}/\n\t\t\t\t\tnumeric = true;\n\t\t\t\t\ttokenRe = new RegExp( \"(\" + regexpN.source + \"){\" + length + \",3}\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"W\":\n\t\t\tcase \"F\":\n\n\t\t\t\t// number l=1:{1}.\n\t\t\t\toneDigitIfLengthOne();\n\t\t\t\tbreak;\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\n\t\t\t\t// number l=1:{1}, l=2:{2}.\n\t\t\t\t// lookup for length >=3.\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\toneDigitIfLengthOne() || twoDigitsIfLengthTwo();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tif ( length === 6 ) {\n\n\t\t\t\t\t// Note: if short day names are not explicitly specified, abbreviated day\n\t\t\t\t\t// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n\t\t\t\t\tlookup([\n\t\t\t\t\t\t\"gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"short\"\n\t\t\t\t\t]) || lookup([\n\t\t\t\t\t\t\"gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"abbreviated\"\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tlookup([\n\t\t\t\t\t\t\"gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\twidths[ length < 3 ? 0 : length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tlookup([\n\t\t\t\t\t\"gregorian/dayPeriods/format/wide\"\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Week\n\t\t\tcase \"w\":\n\n\t\t\t\t// number l1:{1,2}, l2:{2}.\n\t\t\t\toneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();\n\t\t\t\tbreak;\n\n\t\t\t// Day, Hour, Minute, or Second\n\t\t\tcase \"d\":\n\t\t\tcase \"h\":\n\t\t\tcase \"H\":\n\t\t\tcase \"K\":\n\t\t\tcase \"k\":\n\t\t\tcase \"j\":\n\t\t\tcase \"m\":\n\t\t\tcase \"s\":\n\n\t\t\t\t// number l1:{1,2}, l2:{2}.\n\t\t\t\t//\n\t\t\t\t// Lenient parsing:\n\t\t\t\t// - skeleton \"hms\" (i.e., one m) always includes mm for the pattern, i.e., it's\n\t\t\t\t//   impossible to use a different skeleton to parse non-zero-padded minutes,\n\t\t\t\t//   therefore parser accepts both zero-padded and non-zero-padded for m. Similar\n\t\t\t\t//   for seconds s.\n\t\t\t\t// - skeleton \"hms\" (i.e., one h) may include h or hh for the pattern, i.e., it's\n\t\t\t\t//   impossible to use a different skeleton to parser non-zero-padded hours for some\n\t\t\t\t//   locales, therefore parser accepts both zero-padded and non-zero-padded for h.\n\t\t\t\t//   Similar for d (in skeleton yMd).\n\t\t\t\toneOrTwoDigitsIfLengthOneOrTwo();\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\n\t\t\t\t// number {l}.\n\n\t\t\t\t// Unicode equivalent to /\\d{length}/\n\t\t\t\tnumeric = true;\n\t\t\t\ttokenRe = new RegExp( \"(\" + regexpN.source + \"){\" + length + \"}\" );\n\t\t\t\tbreak;\n\n\t\t\tcase \"A\":\n\n\t\t\t\t// number {l+5}.\n\n\t\t\t\t// Unicode equivalent to /\\d{length+5}/\n\t\t\t\tnumeric = true;\n\t\t\t\ttokenRe = new RegExp( \"(\" + regexpN.source + \"){\" + ( length + 5 ) + \"}\" );\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"z\":\n\t\t\tcase \"O\":\n\n\t\t\t\t// O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n\t\t\t\t// OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n\t\t\t\tif ( value === properties[ \"timeZoneNames/gmtZeroFormat\" ] ) {\n\t\t\t\t\ttoken.value = 0;\n\t\t\t\t\ttokenRe = new RegExp( properties[ \"timeZoneNames/gmtZeroFormat\" ] );\n\t\t\t\t} else {\n\t\t\t\t\ttokenRe = hourFormatRe(\n\t\t\t\t\t\tlength < 4 ? \"+H;-H\" : properties[ \"timeZoneNames/hourFormat\" ],\n\t\t\t\t\t\tproperties[ \"timeZoneNames/gmtFormat\" ],\n\t\t\t\t\t\ttimeSeparator\n\t\t\t\t\t);\n\t\t\t\t\tif ( !hourFormatParse( tokenRe, numberParser ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"X\":\n\n\t\t\t\t// Same as x*, except it uses \"Z\" for zero offset.\n\t\t\t\tif ( value === \"Z\" ) {\n\t\t\t\t\ttoken.value = 0;\n\t\t\t\t\ttokenRe = /Z/;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"x\":\n\n\t\t\t\t// x: hourFormat(\"+HH;-HH\")\n\t\t\t\t// xx or xxxx: hourFormat(\"+HHmm;-HHmm\")\n\t\t\t\t// xxx or xxxxx: hourFormat(\"+HH:mm;-HH:mm\")\n\t\t\t\ttokenRe = hourFormatRe(\n\t\t\t\t\tlength === 1 ? \"+HH;-HH\" : ( length % 2 ? \"+HH:mm;-HH:mm\" : \"+HHmm;-HHmm\" )\n\t\t\t\t);\n\t\t\t\tif ( !hourFormatParse( tokenRe ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"'\":\n\t\t\t\ttoken.type = \"literal\";\n\t\t\t\ttokenRe = new RegExp( regexpEscape( removeLiteralQuotes( current ) ) );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttoken.type = \"literal\";\n\t\t\t\ttokenRe = new RegExp( regexpEscape( current ) );\n\t\t}\n\n\t\tif ( !tokenRe ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Get lexeme and consume it.\n\t\tvalue = value.replace( new RegExp( \"^\" + tokenRe.source ), function( lexeme ) {\n\t\t\ttoken.lexeme = lexeme;\n\t\t\tif ( numeric ) {\n\t\t\t\ttoken.value = numberParser( lexeme );\n\t\t\t}\n\t\t\treturn \"\";\n\t\t});\n\n\t\tif ( !token.lexeme ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttokens.push( token );\n\t\treturn true;\n\t});\n\n\tif ( value !== \"\" ) {\n\t\tvalid = false;\n\t}\n\n\treturn valid ? tokens : [];\n};\n\n\n\n\nvar dateParserFn = function( numberParser, parseProperties, tokenizerProperties ) {\n\treturn function dateParser( value ) {\n\t\tvar tokens;\n\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeString( value, \"value\" );\n\n\t\ttokens = dateTokenizer( value, numberParser, tokenizerProperties );\n\t\treturn dateParse( value, tokens, parseProperties ) || null;\n\t};\n};\n\n\n\n\n/**\n * parseProperties( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return parser properties.\n */\nvar dateParseProperties = function( cldr ) {\n\treturn {\n\t\tpreferredTimeData: cldr.supplemental.timeData.preferred()\n\t};\n};\n\n\n\n\nvar objectFilter = function( object, testRe ) {\n\tvar key,\n\t\tcopy = {};\n\n\tfor ( key in object ) {\n\t\tif ( testRe.test( key ) ) {\n\t\t\tcopy[ key ] = object[ key ];\n\t\t}\n\t}\n\n\treturn copy;\n};\n\n\n\n\n/**\n * tokenizerProperties( pattern, cldr )\n *\n * @pattern [String] raw pattern.\n *\n * @cldr [Cldr instance].\n *\n * Return Object with data that will be used by tokenizer.\n */\nvar dateTokenizerProperties = function( pattern, cldr ) {\n\tvar properties = {\n\t\t\tpattern: pattern,\n\t\t\ttimeSeparator: numberSymbol( \"timeSeparator\", cldr )\n\t\t},\n\t\twidths = [ \"abbreviated\", \"wide\", \"narrow\" ];\n\n\tfunction populateProperties( path, value ) {\n\n\t\t// The `dates` and `calendars` trim's purpose is to reduce properties' key size only.\n\t\tproperties[ path.replace( /^.*\\/dates\\//, \"\" ).replace( /calendars\\//, \"\" ) ] = value;\n\t}\n\n\tcldr.on( \"get\", populateProperties );\n\n\tpattern.match( datePatternRe ).forEach(function( current ) {\n\t\tvar chr, length;\n\n\t\tchr = current.charAt( 0 ),\n\t\tlength = current.length;\n\n\t\tif ( chr === \"Z\" && length < 5 ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tlength = 4;\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tcldr.main([\n\t\t\t\t\t\"dates/calendars/gregorian/eras\",\n\t\t\t\t\tlength <= 3 ? \"eraAbbr\" : ( length === 4 ? \"eraNames\" : \"eraNarrow\" )\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"u\": // Extended year. Need to be implemented.\n\t\t\tcase \"U\": // Cyclic year name. Need to be implemented.\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"year pattern `\" + chr + \"`\"\n\t\t\t\t});\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/quarters\",\n\t\t\t\t\t\tchr === \"Q\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\n\t\t\t\t// number l=1:{1,2}, l=2:{2}.\n\t\t\t\t// lookup l=3...\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/months\",\n\t\t\t\t\t\tchr === \"M\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"g\":\n\n\t\t\t\t// Modified Julian day. Need to be implemented.\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"Julian day pattern `g`\"\n\t\t\t\t});\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\n\t\t\t\t// lookup for length >=3.\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tif ( length === 6 ) {\n\n\t\t\t\t\t// Note: if short day names are not explicitly specified, abbreviated day\n\t\t\t\t\t// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"short\"\n\t\t\t\t\t]) || cldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"abbreviated\"\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\twidths[ length < 3 ? 0 : length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tcldr.main(\n\t\t\t\t\t\"dates/calendars/gregorian/dayPeriods/format/wide\"\n\t\t\t\t);\n\t\t\t\tproperties[ \"gregorian/dayPeriods/format/wide\" ] = objectFilter(\n\t\t\t\t\tproperties[ \"gregorian/dayPeriods/format/wide\" ],\n\t\t\t\t\t/^am|^pm/\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"z\":\n\t\t\tcase \"O\":\n\t\t\t\tcldr.main( \"dates/timeZoneNames/gmtFormat\" );\n\t\t\t\tcldr.main( \"dates/timeZoneNames/gmtZeroFormat\" );\n\t\t\t\tcldr.main( \"dates/timeZoneNames/hourFormat\" );\n\t\t\t\tbreak;\n\n\t\t\tcase \"v\":\n\t\t\tcase \"V\":\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"timezone pattern `\" + chr + \"`\"\n\t\t\t\t});\n\t\t}\n\t});\n\n\tcldr.off( \"get\", populateProperties );\n\n\treturn properties;\n};\n\n\n\n\nfunction validateRequiredCldr( path, value ) {\n\tvalidateCldr( path, value, {\n\t\tskip: [\n\t\t\t/dates\\/calendars\\/gregorian\\/dateTimeFormats\\/availableFormats/,\n\t\t\t/dates\\/calendars\\/gregorian\\/days\\/.*\\/short/,\n\t\t\t/supplemental\\/timeData\\/(?!001)/,\n\t\t\t/supplemental\\/weekData\\/(?!001)/\n\t\t]\n\t});\n}\n\n/**\n * .dateFormatter( options )\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Return a date formatter function (of the form below) according to the given options and the\n * default/instance locale.\n *\n * fn( value )\n *\n * @value [Date]\n *\n * Return a function that formats a date according to the given `format` and the default/instance\n * locale.\n */\nGlobalize.dateFormatter =\nGlobalize.prototype.dateFormatter = function( options ) {\n\tvar args, cldr, numberFormatters, pad, pattern, properties, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\tcldr = this.cldr;\n\toptions = options || { skeleton: \"yMd\" };\n\n\targs = [ options ];\n\n\tvalidateDefaultLocale( cldr );\n\n\tcldr.on( \"get\", validateRequiredCldr );\n\tpattern = dateExpandPattern( options, cldr );\n\tproperties = dateFormatProperties( pattern, cldr );\n\tcldr.off( \"get\", validateRequiredCldr );\n\n\t// Create needed number formatters.\n\tnumberFormatters = properties.numberFormatters;\n\tdelete properties.numberFormatters;\n\tfor ( pad in numberFormatters ) {\n\t\tnumberFormatters[ pad ] = this.numberFormatter({\n\t\t\traw: numberFormatters[ pad ]\n\t\t});\n\t}\n\n\treturnFn = dateFormatterFn( numberFormatters, properties );\n\n\truntimeBind( args, cldr, returnFn, [ numberFormatters, properties ] );\n\n\treturn returnFn;\n};\n\n/**\n * .dateParser( options )\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Return a function that parses a string date according to the given `formats` and the\n * default/instance locale.\n */\nGlobalize.dateParser =\nGlobalize.prototype.dateParser = function( options ) {\n\tvar args, cldr, numberParser, parseProperties, pattern, tokenizerProperties, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\tcldr = this.cldr;\n\toptions = options || { skeleton: \"yMd\" };\n\n\targs = [ options ];\n\n\tvalidateDefaultLocale( cldr );\n\n\tcldr.on( \"get\", validateRequiredCldr );\n\tpattern = dateExpandPattern( options, cldr );\n\ttokenizerProperties = dateTokenizerProperties( pattern, cldr );\n\tparseProperties = dateParseProperties( cldr );\n\tcldr.off( \"get\", validateRequiredCldr );\n\n\tnumberParser = this.numberParser({ raw: \"0\" });\n\n\treturnFn = dateParserFn( numberParser, parseProperties, tokenizerProperties );\n\n\truntimeBind( args, cldr, returnFn, [ numberParser, parseProperties, tokenizerProperties ] );\n\n\treturn returnFn;\n};\n\n/**\n * .formatDate( value, options )\n *\n * @value [Date]\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Formats a date or number according to the given options string and the default/instance locale.\n */\nGlobalize.formatDate =\nGlobalize.prototype.formatDate = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeDate( value, \"value\" );\n\n\treturn this.dateFormatter( options )( value );\n};\n\n/**\n * .parseDate( value, options )\n *\n * @value [String]\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Return a Date instance or null.\n */\nGlobalize.parseDate =\nGlobalize.prototype.parseDate = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeString( value, \"value\" );\n\n\treturn this.dateParser( options )( value );\n};\n\nreturn Globalize;\n\n\n\n\n}));\n","/home/travis/build/npmtest/node-npmtest-globalize/node_modules/globalize/dist/globalize/relative-time.js":"/**\n * Globalize v1.2.3\n *\n * http://github.com/jquery/globalize\n *\n * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2017-03-17T01:41Z\n */\n/*!\n * Globalize v1.2.3 2017-03-17T01:41Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"./number\",\n\t\t\t\"./plural\",\n\t\t\t\"cldr/event\",\n\t\t\t\"cldr/supplemental\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Extend global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar formatMessage = Globalize._formatMessage,\n\truntimeBind = Globalize._runtimeBind,\n\tvalidateCldr = Globalize._validateCldr,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterTypeString = Globalize._validateParameterTypeString,\n\tvalidateParameterTypeNumber = Globalize._validateParameterTypeNumber;\n\n\n/**\n * format( value, numberFormatter, pluralGenerator, properties )\n *\n * @value [Number] The number to format\n *\n * @numberFormatter [String] A numberFormatter from Globalize.numberFormatter\n *\n * @pluralGenerator [String] A pluralGenerator from Globalize.pluralGenerator\n *\n * @properties [Object] containing relative time plural message.\n *\n * Format relative time.\n */\nvar relativeTimeFormat = function( value, numberFormatter, pluralGenerator, properties ) {\n\n\tvar relativeTime,\n\t\tmessage = properties[ \"relative-type-\" + value ];\n\n\tif ( message ) {\n\t\treturn message;\n\t}\n\n\trelativeTime = value <= 0 ? properties[ \"relativeTime-type-past\" ]\n\t\t: properties[ \"relativeTime-type-future\" ];\n\n\tvalue = Math.abs( value );\n\n\tmessage = relativeTime[ \"relativeTimePattern-count-\" + pluralGenerator( value ) ];\n\treturn formatMessage( message, [ numberFormatter( value ) ] );\n};\n\n\n\n\nvar relativeTimeFormatterFn = function( numberFormatter, pluralGenerator, properties ) {\n\treturn function relativeTimeFormatter( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeNumber( value, \"value\" );\n\n\t\treturn relativeTimeFormat( value, numberFormatter, pluralGenerator, properties );\n\t};\n\n};\n\n\n\n\n/**\n * properties( unit, cldr, options )\n *\n * @unit [String] eg. \"day\", \"week\", \"month\", etc.\n *\n * @cldr [Cldr instance].\n *\n * @options [Object]\n * - form: [String] eg. \"short\" or \"narrow\". Or falsy for default long form.\n *\n * Return relative time properties.\n */\nvar relativeTimeProperties = function( unit, cldr, options ) {\n\n\tvar form = options.form,\n\t\traw, properties, key, match;\n\n\tif ( form ) {\n\t\tunit = unit + \"-\" + form;\n\t}\n\n\traw = cldr.main( [ \"dates\", \"fields\", unit ] );\n\tproperties = {\n\t\t\"relativeTime-type-future\": raw[ \"relativeTime-type-future\" ],\n\t\t\"relativeTime-type-past\": raw[ \"relativeTime-type-past\" ]\n\t};\n\tfor ( key in raw ) {\n\t\tif ( raw.hasOwnProperty( key ) ) {\n\t\t\tmatch = /relative-type-(-?[0-9]+)/.exec( key );\n\t\t\tif ( match ) {\n\t\t\t\tproperties[ key ] = raw[ key ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn properties;\n};\n\n\n\n\n/**\n * .formatRelativeTime( value, unit [, options] )\n *\n * @value [Number] The number of unit to format.\n *\n * @unit [String] see .relativeTimeFormatter() for details.\n *\n * @options [Object] see .relativeTimeFormatter() for details.\n *\n * Formats a relative time according to the given unit, options, and the default/instance locale.\n */\nGlobalize.formatRelativeTime =\nGlobalize.prototype.formatRelativeTime = function( value, unit, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\n\treturn this.relativeTimeFormatter( unit, options )( value );\n};\n\n/**\n * .relativeTimeFormatter( unit [, options ])\n *\n * @unit [String] String value indicating the unit to be formatted. eg. \"day\", \"week\", \"month\", etc.\n *\n * @options [Object]\n * - form: [String] eg. \"short\" or \"narrow\". Or falsy for default long form.\n *\n * Returns a function that formats a relative time according to the given unit, options, and the\n * default/instance locale.\n */\nGlobalize.relativeTimeFormatter =\nGlobalize.prototype.relativeTimeFormatter = function( unit, options ) {\n\tvar args, cldr, numberFormatter, pluralGenerator, properties, returnFn;\n\n\tvalidateParameterPresence( unit, \"unit\" );\n\tvalidateParameterTypeString( unit, \"unit\" );\n\n\tcldr = this.cldr;\n\toptions = options || {};\n\n\targs = [ unit, options ];\n\n\tvalidateDefaultLocale( cldr );\n\n\tcldr.on( \"get\", validateCldr );\n\tproperties = relativeTimeProperties( unit, cldr, options );\n\tcldr.off( \"get\", validateCldr );\n\n\tnumberFormatter = this.numberFormatter( options );\n\tpluralGenerator = this.pluralGenerator();\n\n\treturnFn = relativeTimeFormatterFn( numberFormatter, pluralGenerator, properties );\n\n\truntimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );\n\n\treturn returnFn;\n};\n\nreturn Globalize;\n\n\n\n\n}));\n","/home/travis/build/npmtest/node-npmtest-globalize/node_modules/globalize/dist/globalize/unit.js":"/**\n * Globalize v1.2.3\n *\n * http://github.com/jquery/globalize\n *\n * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2017-03-17T01:41Z\n */\n/*!\n * Globalize v1.2.3 2017-03-17T01:41Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"./number\",\n\t\t\t\"./plural\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Extend global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar formatMessage = Globalize._formatMessage,\n\truntimeBind = Globalize._runtimeBind,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,\n\tvalidateParameterTypeNumber = Globalize._validateParameterTypeNumber,\n\tvalidateParameterTypeString = Globalize._validateParameterTypeString;\n\n\n/**\n * format( value, numberFormatter, pluralGenerator, unitProperies )\n *\n * @value [Number]\n *\n * @numberFormatter [Object]: A numberFormatter from Globalize.numberFormatter.\n *\n * @pluralGenerator [Object]: A pluralGenerator from Globalize.pluralGenerator.\n *\n * @unitProperies [Object]: localized unit data from cldr.\n *\n * Format units such as seconds, minutes, days, weeks, etc.\n *\n * OBS:\n *\n * Unit Sequences are not implemented.\n * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#Unit_Sequences\n *\n * Duration Unit (for composed time unit durations) is not implemented.\n * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#durationUnit\n */\nvar unitFormat = function( value, numberFormatter, pluralGenerator, unitProperties ) {\n\tvar compoundUnitPattern = unitProperties.compoundUnitPattern, dividend, dividendProperties,\n\t\tformattedValue, divisor, divisorProperties, message, pluralValue;\n\n\tunitProperties = unitProperties.unitProperties;\n\tformattedValue = numberFormatter( value );\n\tpluralValue = pluralGenerator( value );\n\n\t// computed compound unit, eg. \"megabyte-per-second\".\n\tif ( unitProperties instanceof Array ) {\n\t\tdividendProperties = unitProperties[ 0 ];\n\t\tdivisorProperties = unitProperties[ 1 ];\n\n\t\tdividend = formatMessage( dividendProperties[ pluralValue ], [ value ] );\n\t\tdivisor = formatMessage( divisorProperties.one, [ \"\" ] ).trim();\n\n\t\treturn formatMessage( compoundUnitPattern, [ dividend, divisor ] );\n\t}\n\n\tmessage = unitProperties[ pluralValue ];\n\n\treturn formatMessage( message, [ formattedValue ] );\n};\n\n\n\n\nvar unitFormatterFn = function( numberFormatter, pluralGenerator, unitProperties ) {\n\treturn function unitFormatter( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeNumber( value, \"value\" );\n\n\t\treturn unitFormat( value, numberFormatter, pluralGenerator, unitProperties );\n\t};\n\n};\n\n\n\n\n/**\n * categories()\n *\n * Return all unit categories.\n */\nvar unitCategories = [ \"acceleration\", \"angle\", \"area\", \"digital\", \"duration\", \"length\", \"mass\", \"power\",\n\"pressure\", \"speed\", \"temperature\", \"volume\" ];\n\n\n\n\nfunction stripPluralGarbage( data ) {\n\tvar aux, pluralCount;\n\n\tif ( data ) {\n\t\taux = {};\n\t\tfor ( pluralCount in data ) {\n\t\t\taux[ pluralCount.replace( /unitPattern-count-/, \"\" ) ] = data[ pluralCount ];\n\t\t}\n\t}\n\n\treturn aux;\n}\n\n/**\n * get( unit, form, cldr )\n *\n * @unit [String] The full type-unit name (eg. duration-second), or the short unit name\n * (eg. second).\n *\n * @form [String] A string describing the form of the unit representation (eg. long,\n * short, narrow).\n *\n * @cldr [Cldr instance].\n *\n * Return the plural map of a unit, eg: \"second\"\n * { \"one\": \"{0} second\",\n *   \"other\": \"{0} seconds\" }\n * }\n *\n * Or the Array of plural maps of a compound-unit, eg: \"foot-per-second\"\n * [ { \"one\": \"{0} foot\",\n *     \"other\": \"{0} feet\" },\n *   { \"one\": \"{0} second\",\n *     \"other\": \"{0} seconds\" } ]\n *\n * Uses the precomputed form of a compound-unit if available, eg: \"mile-per-hour\"\n * { \"displayName\": \"miles per hour\",\n *    \"unitPattern-count-one\": \"{0} mile per hour\",\n *    \"unitPattern-count-other\": \"{0} miles per hour\"\n * },\n *\n * Also supports \"/\" instead of \"-per-\", eg. \"foot/second\", using the precomputed form if\n * available.\n *\n * Or the Array of plural maps of a compound-unit, eg: \"foot-per-second\"\n * [ { \"one\": \"{0} foot\",\n *     \"other\": \"{0} feet\" },\n *   { \"one\": \"{0} second\",\n *     \"other\": \"{0} seconds\" } ]\n *\n * Or undefined in case the unit (or a unit of the compound-unit) doesn't exist.\n */\nvar get = function( unit, form, cldr ) {\n\tvar ret;\n\n\t// Ensure that we get the 'precomputed' form, if present.\n\tunit = unit.replace( /\\//, \"-per-\" );\n\n\t// Get unit or <category>-unit (eg. \"duration-second\").\n\t[ \"\" ].concat( unitCategories ).some(function( category ) {\n\t\treturn ret = cldr.main([\n\t\t\t\"units\",\n\t\t\tform,\n\t\t\tcategory.length ? category + \"-\" + unit : unit\n\t\t]);\n\t});\n\n\t// Rename keys s/unitPattern-count-//g.\n\tret = stripPluralGarbage( ret );\n\n\t// Compound Unit, eg. \"foot-per-second\" or \"foot/second\".\n\tif ( !ret && ( /-per-/ ).test( unit ) ) {\n\n\t\t// \"Some units already have 'precomputed' forms, such as kilometer-per-hour;\n\t\t// where such units exist, they should be used in preference\" UTS#35.\n\t\t// Note that precomputed form has already been handled above (!ret).\n\n\t\t// Get both recursively.\n\t\tunit = unit.split( \"-per-\" );\n\t\tret = unit.map(function( unit ) {\n\t\t\treturn get( unit, form, cldr );\n\t\t});\n\t\tif ( !ret[ 0 ] || !ret[ 1 ] ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn ret;\n};\n\nvar unitGet = get;\n\n\n\n\n/**\n * properties( unit, form, cldr )\n *\n * @unit [String] The full type-unit name (eg. duration-second), or the short unit name\n * (eg. second).\n *\n * @form [String] A string describing the form of the unit representation (eg. long,\n * short, narrow).\n *\n * @cldr [Cldr instance].\n */\nvar unitProperties = function( unit, form, cldr ) {\n\tvar compoundUnitPattern, unitProperties;\n\n\tcompoundUnitPattern = cldr.main( [ \"units\", form, \"per/compoundUnitPattern\" ] );\n\tunitProperties = unitGet( unit, form, cldr );\n\n\treturn {\n\t\tcompoundUnitPattern: compoundUnitPattern,\n\t\tunitProperties: unitProperties\n\t};\n};\n\n\n\n\n/**\n * Globalize.formatUnit( value, unit, options )\n *\n * @value [Number]\n *\n * @unit [String]: The unit (e.g \"second\", \"day\", \"year\")\n *\n * @options [Object]\n * - form: [String] \"long\", \"short\" (default), or \"narrow\".\n *\n * Format units such as seconds, minutes, days, weeks, etc.\n */\nGlobalize.formatUnit =\nGlobalize.prototype.formatUnit = function( value, unit, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\n\treturn this.unitFormatter( unit, options )( value );\n};\n\n/**\n * Globalize.unitFormatter( unit, options )\n *\n * @unit [String]: The unit (e.g \"second\", \"day\", \"year\")\n *\n * @options [Object]\n * - form: [String] \"long\", \"short\" (default), or \"narrow\".\n *\n * - numberFormatter: [Function] a number formatter function. Defaults to Globalize\n *   `.numberFormatter()` for the current locale using the default options.\n */\nGlobalize.unitFormatter =\nGlobalize.prototype.unitFormatter = function( unit, options ) {\n\tvar args, form, numberFormatter, pluralGenerator, returnFn, properties;\n\n\tvalidateParameterPresence( unit, \"unit\" );\n\tvalidateParameterTypeString( unit, \"unit\" );\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\n\targs = [ unit, options ];\n\tform = options.form || \"long\";\n\tproperties = unitProperties( unit, form, this.cldr );\n\n\tnumberFormatter = options.numberFormatter || this.numberFormatter();\n\tpluralGenerator = this.pluralGenerator();\n\treturnFn = unitFormatterFn( numberFormatter, pluralGenerator, properties );\n\n\truntimeBind( args, this.cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );\n\n\treturn returnFn;\n};\n\nreturn Globalize;\n\n\n\n\n}));\n"}